<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>File和IO</title>
    <url>/2024/10/08/File%E5%92%8CIO/</url>
    <content><![CDATA[<h1 id="File和IO"><a href="#File和IO" class="headerlink" title="File和IO"></a>File和IO</h1><span id="more"></span>
<h1 id="1-File"><a href="#1-File" class="headerlink" title="1. File"></a>1. File</h1><h2 id="1-1-File-概述"><a href="#1-1-File-概述" class="headerlink" title="1.1 File 概述"></a><strong>1.1 File 概述</strong></h2><p>l  java.io.File 类是专门对文件进行操作的类</p>
<p>l  Java中目录被看成是一个特殊的文件</p>
<p>l  File类只能对文件本身进行操作，不能对文件内容操作(I&#x2F;O 流）</p>
<h2 id="1-2-File-对象的创建"><a href="#1-2-File-对象的创建" class="headerlink" title="1.2 File 对象的创建"></a>1.2 File 对象的创建</h2><p>public  File(String pathname)</p>
<p>l  pathname表示文件的路径，该路径可以是绝对路径，也可以是相对路径。</p>
<p>l  在不同操作系统中，分隔符的表示不同。为了实现代码跨平台，建议是有<strong>File.separator</strong>来表示<strong>。</strong></p>
<h2 id="1-3-获取路径及文件名"><a href="#1-3-获取路径及文件名" class="headerlink" title="1.3 获取路径及文件名"></a><strong>1.3 获取路径及文件名</strong></h2><p>l  public String getName()  获得文件名包括后缀名</p>
<p>l  public String getAbsolutePath()  获得绝对路径</p>
<p>l  public String getParent()  获得父目录路径</p>
<p>l  public File getParentFile()  获得父目录</p>
<h2 id="1-4-获取属性"><a href="#1-4-获取属性" class="headerlink" title="1.4 获取属性"></a><strong>1.4 获取属性</strong></h2><p>l  public boolean exists()  是否存在</p>
<p>l  public boolean isDirectory()  是否是目录</p>
<p>l  public boolean isFile()  是否是文件</p>
<p>l  public long length()   文件长度，以字节为单位</p>
<h2 id="1-5-文件创建和删除"><a href="#1-5-文件创建和删除" class="headerlink" title="1.5 文件创建和删除"></a><strong>1.5 文件创建和删除</strong></h2><p>l  public boolean createNewFile()  创建文件，要求目录存在。文件存在则不会重新创建</p>
<p>l  public boolean delete()   删除文件，如果是目录必须是空才能删除</p>
<p>l  public boolean renameTo(File dest) 重新命名文件，原路径文件删除，相当于剪切复制</p>
<p>l  public boolean mkdir() 创建单层目录</p>
<p>l  public boolean mkdirs()  创建多层目录</p>
<h2 id="1-6-文件遍历"><a href="#1-6-文件遍历" class="headerlink" title="1.6 文件遍历"></a><strong>1.6 文件遍历</strong></h2><p>l  public String[] list()  返回此目录中的子文件名数组</p>
<p>l  public File[] listFiles()  返回此目录中的子文件数组</p>
<p><strong>递归</strong></p>
<p>l  所谓递归是指方法内部在某个条件下调用自身的过程</p>
<p>l  递归必须有终止递归的条件，否则会形成死循环</p>
<h2 id="1-7-过滤器"><a href="#1-7-过滤器" class="headerlink" title="1.7 过滤器"></a><strong>1.7 过滤器</strong></h2><p>l  File[] listFiles(FilenameFilter filter)  返回符合过滤条件的文件&#x2F;目录</p>
<p>FilenameFilter 接口内部方法：</p>
<p>public boolean accept(File dir, String name) { &#x2F;&#x2F;dir表示文件目录，name表示文件名</p>
<p>​    return true; &#x2F;&#x2F;true表示符合过滤条件</p>
<p>}</p>
<p>l  public File[] listFiles(FileFilter filter)  返回此目录中满足过滤器的文件&#x2F;目录</p>
<p>FileFilter 接口内部方法：</p>
<p>public boolean accept(File pathname) {&#x2F;&#x2F;表示过滤文件的绝对路径</p>
<p>​    return true; &#x2F;&#x2F;true表示符合过滤条件</p>
<p>}</p>
<h1 id="2-I-O-流"><a href="#2-I-O-流" class="headerlink" title="2. I&#x2F;O 流"></a>2. I&#x2F;O 流</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1 概述</strong></h2><p>流是从数据源到接收端的有序数据。在Java程序中，对于数据的传输以流的方式进行。</p>
<p>I 指 input 输入，O 指 output 输出。I&#x2F;O流就是指输入输出流。</p>
<h3 id="2-1-1-IO流的分类"><a href="#2-1-1-IO流的分类" class="headerlink" title="2.1.1 IO流的分类"></a><strong>2.1.1 IO流的分类</strong></h3><p>l  按传输方向划分</p>
<p><strong>输入流</strong>：程序可以从中读取数据的流</p>
<p><strong>输出流</strong>：程序能向其中写入数据的流</p>
<p>l  按传输单位划分：</p>
<p><strong>字节流</strong>：以字节为单位传输数据的流</p>
<p><strong>字符流</strong>：以字符为单位传输数据的流</p>
<p>l  按传输方式划分：</p>
<p><strong>节点流</strong>：用于直接操作目标设备的流</p>
<p><strong>处理流</strong>：是对一个已存在的流的连接和封装，通过对数据的处理为程序提供</p>
<h2 id="2-1-2-IO流的基类"><a href="#2-1-2-IO流的基类" class="headerlink" title="2.1.2 IO流的基类"></a><strong>2.1.2 IO流的基类</strong></h2><p>在java中所有的流都继承自以上四个类，这四个类是抽象类，封装了流操作的基本方法。</p>
<p>l  InputStream 字节输入流 和 <strong>OutputStream</strong> <strong>字节输出流</strong></p>
<p>l  Reader 字符输入流 和 Writer 字符输出流</p>
<h3 id="2-2-文件流"><a href="#2-2-文件流" class="headerlink" title="2.2 文件流"></a><strong>2.2 文件流</strong></h3><p>文件流属于节点流，一般为创建处理流做准备。</p>
<p><strong>2.3.1 FileInputStream</strong></p>
<p>l  FileInputStream(String filepath)</p>
<p>l  FileInputStream(File fileObj)</p>
<p>两个构造方法都可能引发FileNotFoundException异常。filepath是文件的绝对路径，也可是相对路径。</p>
<h3 id="2-3-2-FileOutputStream"><a href="#2-3-2-FileOutputStream" class="headerlink" title="2.3.2 FileOutputStream"></a><strong>2.3.2 FileOutputStream</strong></h3><p>l  FileOutputStream(String filePath)</p>
<p>l  FileOutputStream(String filePath, boolean append)，a<strong>ppend****为true，表示是否追加写，默认为false</strong>。</p>
<p>l  FileOutputStream(File fileObj)</p>
<p>三个构造方法都可能引发IOException或SecurityException异常。如试图打开一个只读文件，会引发一个IOException异常。</p>
<p>FileOutputStream 的创建不依赖于文件是否存在。在创建对象时，FileOutputStream会在打开输出文件之前就创建它。</p>
<h3 id="2-3-3-FileReader"><a href="#2-3-3-FileReader" class="headerlink" title="2.3.3 FileReader"></a><strong>2.3.3 FileReader</strong></h3><p>l  FileReader(String filePath)</p>
<p>l  FileReader(File fileObj)</p>
<h3 id="2-3-4-FileWriter"><a href="#2-3-4-FileWriter" class="headerlink" title="2.3.4 FileWriter"></a><strong>2.3.4 FileWriter</strong></h3><p>l  FileWriter(String filePath)</p>
<p>l  FileWriter(String filePath, boolean append)</p>
<p>l  FileWriter(File fileObj)</p>
<h2 id="2-3-缓冲流"><a href="#2-3-缓冲流" class="headerlink" title="2.3 缓冲流"></a><strong>2.3 缓冲流</strong></h2><p>缓冲流是建立在相应的节点流之上，<strong>对读写的数据提供了缓冲的功能</strong>，<strong>提高了读写的效率</strong>，还增加了一些新的方法。</p>
<h3 id="2-3-1-BufferedInputStream"><a href="#2-3-1-BufferedInputStream" class="headerlink" title="2.3.1 BufferedInputStream"></a><strong>2.3.1 BufferedInputStream</strong></h3><p><strong>构造方法</strong></p>
<p>l  public BufferedInputStream(InputStream is) 参数是一个节点流。</p>
<p><strong>常用方法</strong></p>
<p>l  public int read(byte[] b) 将数据读取到指定的 byte 数组中。如果返回-1，表示数据读取完毕。</p>
<p>l  public void close() throws IOException 关闭此输入流并释放与此流关联的所有系统资源。<strong>即关闭缓冲流，它所关联的节点流也将关闭</strong>。</p>
<h3 id="2-3-2-Buffer"><a href="#2-3-2-Buffer" class="headerlink" title="2.3.2 Buffer"></a><strong>2.3.2 Buffer</strong></h3><p><strong>构造方法</strong> </p>
<p>l  public BufferedOutputStream(OutputStream os); </p>
<p><strong>常用方法</strong></p>
<p>l  public int write(byte[] b); </p>
<p>l  public int write(byte[] b, int off, int len); </p>
<p>l  public void close() throws IOException 关闭此输出流并释放与此流关联的所有系统资源。</p>
<h3 id="2-3-3-BufferedReader"><a href="#2-3-3-BufferedReader" class="headerlink" title="2.3.3 BufferedReader"></a><strong>2.3.3 BufferedReader</strong></h3><p>l  public String readLine() 读取一行数据</p>
<h3 id="2-3-4-BufferedWriter"><a href="#2-3-4-BufferedWriter" class="headerlink" title="2.3.4 BufferedWriter"></a><strong>2.3.4 BufferedWriter</strong></h3><p>l  public void write(String str) 写入字符串</p>
<p>l  public void newLine() 写入换行</p>
<h2 id="2-4-序列化"><a href="#2-4-序列化" class="headerlink" title="2.4 序列化"></a><strong>2.4 序列化</strong></h2><h3 id="2-4-1-序列化和反序列化"><a href="#2-4-1-序列化和反序列化" class="headerlink" title="2.4.1 序列化和反序列化"></a><strong>2.4.1 序列化和反序列化</strong></h3><p>l  序列化：将对象写入到IO流中(以二进制数组写入的)</p>
<p>l  反序列化：从IO流中(读取二进制数据)恢复对象</p>
<h3 id="2-4-2-对象流"><a href="#2-4-2-对象流" class="headerlink" title="2.4.2 对象流"></a><strong>2.4.2 对象流</strong></h3><p>l  ObjectOutputStream 实现序列化</p>
<p>l  ObjectInputStream 实现反序列化</p>
<h3 id="2-4-3-Serializable"><a href="#2-4-3-Serializable" class="headerlink" title="2.4.3 Serializable"></a><strong>2.4.3 Serializable</strong></h3><p>Serializable接口是一个标记接口，一旦实现了此接口，该类的对象就可以进行序列化操作了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小张&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\test\\test.txt&quot;</span>));</span><br><span class="line">    oos.writeObject(p);</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\test\\test.txt&quot;</span>));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">readP</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">    System.out.println(readP);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>Java 常用 API</title>
    <url>/2024/10/08/Java-%E5%B8%B8%E7%94%A8-API/</url>
    <content><![CDATA[<h1 id="Java-常用-API"><a href="#Java-常用-API" class="headerlink" title="Java 常用 API"></a>Java 常用 API</h1><span id="more"></span>
<p><strong>1. 查看源码和API</strong><br><strong>ctrl+右键</strong></p>
<h1 id="2-Object"><a href="#2-Object" class="headerlink" title="2. Object"></a>2. Object</h1><p><strong>在java中任何类都直接或者间接的继承了Object类</strong></p>
<h2 id="2-1-和-equals-的区别"><a href="#2-1-和-equals-的区别" class="headerlink" title="2.1 &#x3D;&#x3D; 和 equals 的区别"></a>2.1 &#x3D;&#x3D; 和 equals 的区别</h2><p>&#x3D;&#x3D;：比较两个对象的内存地址是否相等<br>equals：默认是比较两个对象的内存地址是否相等。有时候会重写equals方法来定义两个对象逻辑上是否相等。</p>
<h2 id="2-2-boolean-equals-Object-obj"><a href="#2-2-boolean-equals-Object-obj" class="headerlink" title="2.2  boolean  equals(Object  obj)"></a>2.2  boolean  equals(Object  obj)</h2><p>判断内存地址是否一致，一致返回true，否则返回false。</p>
<p>有时候根据实际的业务需求对该方法进行重写，来定义自己的“相等”逻辑</p>
<h2 id="2-3-int-hashCode"><a href="#2-3-int-hashCode" class="headerlink" title="2.3 int  hashCode()"></a>2.3 int  hashCode()</h2><p>返回值为十进制的int值，可理解为对象在内存中的地址值(唯一)</p>
<p>如果重写equals()，一般需要重写hashCode()方法。</p>
<p>重写的原则是所有参与equals()计算的属性，都要参与hashCode()计算。</p>
<p>hashCode一般计算方法</p>
<p>- boolean类型： data ? 0 : 1 </p>
<p>- byte、char、short或者int类型： data  </p>
<p>- long类型： (int)(data ^ (data  &gt;&gt;&gt; 32))</p>
<p>- double类型： Double.doubleToLongBits(data)  </p>
<p>- 对象引用： data.hashCode() </p>
<p><strong>案例：两本书如果书名和价格相同，视为相同。</strong></p>
<h2 id="2-4-String-toString"><a href="#2-4-String-toString" class="headerlink" title="2.4 String  toString()"></a>2.4 String  toString()</h2><p>该方法的返回值描述了当前对象的有关信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认是返回格式：对象所属类的类名+@+十六进制的hashCode值</p>
<p>该方法在子类中一般需要重写来返回属性值，例如String、Date等</p>
<h1 id="3-基本类型的包装类"><a href="#3-基本类型的包装类" class="headerlink" title="3 基本类型的包装类"></a>3 基本类型的包装类</h1><p><strong>Java中的8种基本数据类型，非引用类型，只能进行基本的运算。</strong></p>
<p><strong>Java给每种基本数据类型分别匹配了一个类，用于扩展功能，称为基本类型的包装类(又称为封装类)。</strong></p>
<h2 id="3-1-封装类的体系结构"><a href="#3-1-封装类的体系结构" class="headerlink" title="3.1 封装类的体系结构"></a>3.1 封装类的体系结构</h2><p>Object：Boolean、Character、Number（Byte、Short、Integer、Long、Float、Double）</p>
<h2 id="3-2-Integer"><a href="#3-2-Integer" class="headerlink" title="3.2 Integer"></a>3.2 Integer</h2><p>常量</p>
<p><code>MAX_VALUE，MIN_VALUE</code></p>
<p>构造方法</p>
<p><code>Integer(int  i)，Inter(String i)</code></p>
<p>装箱和拆箱</p>
<p>把基本类型的数据转为对应的封装类对象称为装箱。把封装类对象转换为对应的基本类型数据。</p>
<p>自jdk1.5开始，java增加对基本数据类型的自动装箱和自动拆箱的操作。</p>
<p>Integet i1 &#x3D; new Integer(10);  &#x2F;&#x2F; 装箱</p>
<p>Integet i2 &#x3D; 10; &#x2F;&#x2F; 自动装箱</p>
<p>Integet i &#x3D; new Integer(10);</p>
<p>int a &#x3D; i.intValue(); &#x2F;&#x2F; 拆箱</p>
<p>int a2 &#x3D; i; &#x2F;&#x2F; 自动拆箱</p>
<p>注意事项：装箱和自动装箱的区别</p>
<p>Integer t1 &#x3D; new Integer(10);</p>
<p>Integer t2 &#x3D; new Integer(10);</p>
<p>System.out.println(t1 &#x3D;&#x3D; t2);  &#x2F;&#x2F; false, 开辟新的存储空间</p>
<p>System.out.println(i1.intValue() &#x3D;&#x3D; i2.intValue()); &#x2F;&#x2F; true, 值比较</p>
<p>Integer i1 &#x3D; 10;</p>
<p>Integer i2 &#x3D; 10;</p>
<p>System.out.println(i1 &#x3D;&#x3D; i2);  &#x2F;&#x2F; true, 使用常量池赋值</p>
<p>Integer o1 &#x3D; 1000;</p>
<p>Integer o2 &#x3D; 1000;</p>
<p>System.out.println(o1 &#x3D;&#x3D; o2);  &#x2F;&#x2F; false, 超过byte取值范围，开辟新的存储空间</p>
<p>和字符串的相互转换</p>
<p>Integer：</p>
<p>public static Integer valueOf(String s)</p>
<p>public static int parseInt(String s)  </p>
<p>String:  </p>
<p>public static String valueOf(int i)</p>
<p><strong>3.3 Character</strong></p>
<table>
<thead>
<tr>
<th><strong>方 法  原 型</strong></th>
<th><strong>说</strong> <strong>明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean  isLetter(char ch)</td>
<td>判断字符ch是否为英文字母</td>
</tr>
<tr>
<td>boolean  isDigit(char ch)</td>
<td>判断字符ch是否为0~9之间的数字</td>
</tr>
<tr>
<td>boolean  isUpperCase(char ch)</td>
<td>判断字符ch是否为大写形式</td>
</tr>
<tr>
<td>boolean  isLowerCase(char ch)</td>
<td>判断字符ch是否为小写形式</td>
</tr>
<tr>
<td>boolean  isWhitespace(char ch)</td>
<td>判断字符ch是否为空格或换行符</td>
</tr>
</tbody></table>
<h1 id="4-BigDecimal和BigInteger"><a href="#4-BigDecimal和BigInteger" class="headerlink" title="4. BigDecimal和BigInteger"></a>4. BigDecimal和BigInteger</h1><p><strong>BigDecimal类位于在java.math包中提供的，用来对超过16位有效位的浮点数进行精确的运算。BigInteger与BigDecimal类似，可以操作长度超过了long的数据。这些大数可以以字符串的形式传入。</strong></p>
<p>class BigDecimal extends Number implements Comparable</p>
<h1 id="4-1-BigDecimal与double"><a href="#4-1-BigDecimal与double" class="headerlink" title="4.1 BigDecimal与double"></a>4.1 BigDecimal与double</h1><p>double可以处理64位有效数，但在实际应用中，可能需要对更大或者更小的数进行运算和处理。但是Double.valueOf(String) 和Float.valueOf(String)会丢失精度。一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用Float和Double处理，速度比较快。如果我们需要精确计算的结果，则必须使用BigDecimal类来操作。</p>
<h1 id="4-2-构造函数"><a href="#4-2-构造函数" class="headerlink" title="4.2 构造函数"></a>4.2 构造函数</h1><p>BigDecimal(int)</p>
<p>BigDecimal(double)</p>
<p>BigDecimal(long)</p>
<p>BigDecimal(String)</p>
<p>由于double精度的不确定性，建议使用String类型参数</p>
<p>BigDecimal bd1 &#x3D; new BigDecimal(0.1);</p>
<p>System.out.println(bd1);</p>
<p>&#x2F;&#x2F;0.1000000000000000055511151231257827021181583404541015625</p>
<p>BigDecimal bd2 &#x3D; new BigDecimal(“0.1”);</p>
<p>System.out.println(bd2);</p>
<p>&#x2F;&#x2F;0.1</p>
<h2 id="4-3-常用方法"><a href="#4-3-常用方法" class="headerlink" title="4.3 常用方法"></a>4.3 常用方法</h2><p>BigDecimal所创建的是对象，故我们不能使用传统的+、-、*、&#x2F;等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。</p>
<p>add(BigDecimal)BigDecimal对象中的值相加，返回BigDecimal对象</p>
<p>subtract(BigDecimal)BigDecimal对象中的值相减，返回BigDecimal对象</p>
<p>multiply(BigDecimal)BigDecimal对象中的值相乘，返回BigDecimal对象</p>
<p>divide(BigDecimal)BigDecimal对象中的值相除，返回BigDecimal对象</p>
<p>toString()将BigDecimal对象中的值转换成字符串</p>
<p>doubleValue()将BigDecimal对象中的值转换成双精度数</p>
<p>floatValue()将BigDecimal对象中的值转换成单精度数</p>
<p>longValue()将BigDecimal对象中的值转换成长整数</p>
<p>intValue()将BigDecimal对象中的值转换成整数</p>
<h1 id="5-Math"><a href="#5-Math" class="headerlink" title="5. Math"></a>5. Math</h1><p><strong>Math 类提供了基本数学运算和几何函数相关的常量和方法。Math类是final类，并且它的所有成员变量和成员方法都是静态static的。</strong></p>
<p>double pow (double a, double b) 计算 a 的 b 次方</p>
<p>double sqrt  (double a)  计算给定值的平方根</p>
<p>int abs (int a) 计算 int 类型值 a的绝对值。也有 long、float 和 double 类型参数的相关方法。</p>
<p>double ceil (double a) 返回大于等于 a的最小整数的double值</p>
<p>double floor (double a) 返回小于等于 a的最大整数的double值</p>
<p>int round(float a) 返回四舍五入整数</p>
<p>int max(int a, int b) 返回 int 型值 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数</p>
<p>int min(int a, int b) 返回 a 和 b 中的较小值，也可接收 long、float 和 double 类型的参数</p>
<h1 id="6-Random"><a href="#6-Random" class="headerlink" title="6. Random"></a>6. Random</h1><p><strong>Random类用于生成随机数</strong></p>
<h2 id="6-1-构造方法"><a href="#6-1-构造方法" class="headerlink" title="6.1 构造方法"></a>6.1 构造方法</h2><p>Random(long seed) 创建一个新的随机数生成器。内部会使用long型数据作为种子，按照一定算法生成并返回相同的数字序列。</p>
<p>Random() 创建一个新的随机数生成器。本质是使用当前系统时间对应的毫秒数作为种子。</p>
<h2 id="6-2-常用方法"><a href="#6-2-常用方法" class="headerlink" title="6.2 常用方法"></a>6.2 常用方法</h2><p>nextInt() 产生下一个int类型的随机数,值位于int类型的取值范围 </p>
<p>nextInt(int n) 产生下一个int类型的随机数,值大于等于0,并且小于n</p>
<p>nextFloat() 产生一个float类型的随机数,大于等于0并且小于1.0</p>
<p>nextDouble() 产生一个double类型的随机数,大于等于0并且小于1.0</p>
<p>nextLong() 产生一个long类型的随机数,值位于long类型的取值范围</p>
<h1 id="7-UUID"><a href="#7-UUID" class="headerlink" title="7. UUID"></a>7. UUID</h1><p>UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写。</p>
<p>UUID的格式为xxxxxxxx—xxxx—xxxx—xxxx—xxxxxxxxxxxx。UUID是16字节128位长的数字，通常以36字节的字符串表示。</p>
<p>UUID uuid &#x3D; UUID.randomUUID(); &#x2F;&#x2F; 获得UUID</p>
<p>String uid &#x3D; uuid.toString(); &#x2F;&#x2F; 将UUID转换为String</p>
<h1 id="8-String、StringBuffer-和-StringBuilder"><a href="#8-String、StringBuffer-和-StringBuilder" class="headerlink" title="8. String、StringBuffer 和 StringBuilder"></a>8. String、StringBuffer 和 StringBuilder</h1><h2 id="8-1-String"><a href="#8-1-String" class="headerlink" title="8.1 String"></a>8.1 String</h2><p><strong>String是字符串类型，java中字符串使用双引号表示。String类是final类，不能有子类。</strong></p>
<h3 id="8-1-1-创建字符串对象"><a href="#8-1-1-创建字符串对象" class="headerlink" title="8.1.1 创建字符串对象"></a>8.1.1 创建字符串对象</h3><p>使用new关键字</p>
<p><code>String s1 = new String(“ab”); </code></p>
<p>使用字符串常量直接赋值</p>
<p><code>String s2 = “abc”;</code> </p>
<p>观察：两种方式创建字符串时 equals 和 &#x3D;&#x3D;  的区别  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">ss1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">ss2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(ss1 == ss2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(ss1.equals(ss2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>




<h3 id="8-1-2-常用方法"><a href="#8-1-2-常用方法" class="headerlink" title="8.1.2 常用方法"></a>8.1.2 常用方法</h3><p><strong>获得新字符串</strong></p>
<p>public String  subString(int beginIndex) </p>
<p>public String  subString(int beginIndex， int endIndex)  获得从beginIndex开始到endIndex结束的子字符串。包括beginIndex的字符，不包含end的字符。</p>
<p>public String toLowerCase()  把字符串中的英文字符全部转换为小写字符，返回值为转换后的新的字符串。</p>
<p>public String toUpperCase()  把字符串中的英文字符全部转换为大写字符，返回值为转换后的新的字符串。</p>
<p>public String trim()  把字符串中的首尾的空白字符去掉</p>
<p>public String replace(CharSequence target,  CharSequence replacement)  使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</p>
<p>public String replace(char oldChar, char newChar)  返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</p>
<p>public String replaceAll(String regex, String replacement)  使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</p>
<p>public replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</p>
<p>public String[] split(String sign) 返回一个数组，该数组由目标字符串根据sign拆分得到</p>
<p>public char[] toCharArray() 将字符串拆分成字符数组</p>
<p><strong>字符串比较</strong></p>
<p>boolean equals(Object anObject) 将此字符串与指定的对象比较。注意此时比较的是内容是否相等。</p>
<p>boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。</p>
<p>boolean startsWith(String value)  检查一个字符串是否以参数字符串开始</p>
<p>boolean endsWith(String value) 检查一个字符串是否以参数个字符串结束</p>
<p>int  compareTo(String s) 当前字符串与目标字符串s按字典序比较，如果当前字符串与s相同返回0，如果大于s，返回正数，否则返回负数</p>
<p><strong>字符串查找</strong></p>
<p>public int length() 计算字符串长度</p>
<p>public int indexOf(int ch) 返回指定字符ch在此字符串中第一次出现处的索引值；如果未出现，则返回 -1。 </p>
<p>public int indexOf(String str) 返回第一次出现的指定子字符串str在此字符串中的索引值；如果未出现，则返回 -1。 </p>
<p>public int lastIndexOf(int ch) 返回最后一次出现的指定字符在此字符串中的索引值；如果未出现，则返回 -1。 </p>
<p>public int lastIndexOf(String str) 返回最后一次出现的指定子字符串str在此字符串中的索引值；如果未出现，则返回 -1。 </p>
<p>public char charAt(int index) 从指定索引index处提取单个字符，索引中的值必须为非负</p>
<p>public  boolean contains(String str) 判断字符串是否包含参数的子串</p>
<h2 id="8-2-StringBuffer"><a href="#8-2-StringBuffer" class="headerlink" title="8.2  StringBuffer"></a>8.2  StringBuffer</h2><h3 id="8-2-1-String-和-StringBuffer"><a href="#8-2-1-String-和-StringBuffer" class="headerlink" title="8.2.1 String 和 StringBuffer"></a>8.2.1 String 和 StringBuffer</h3><p>String字符串的不变性。</p>
<p>一个String对象的长度是固定的，并且不能改变它的内容。每次改变内容后，会产生一个新的String对象。如果频繁操作，会造成系统性能下降。</p>
<p>StringBuffer的理解</p>
<p>StringBuffer称为字符串缓冲区，代表可变的字符序列。StringBuffer会先申请一块内存，存放字符序列，如果字符序列满了，会重新改变缓存区的大小，以容纳更多的字符序列。同时缓冲区存放的内容式允许改变的。</p>
<h3 id="8-2-2-构造方法"><a href="#8-2-2-构造方法" class="headerlink" title="8.2.2 构造方法"></a>8.2.2 构造方法</h3><p>StringBuffer() 构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符</p>
<p>StringBuffer(String str) 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容</p>
<h3 id="8-2-3-常用方法"><a href="#8-2-3-常用方法" class="headerlink" title="8.2.3 常用方法"></a>8.2.3 常用方法</h3><p>StringBuffer append(String str) 将指定的字符串追加到此字符序列 </p>
<p>StringBuffer insert(int offset, String str) 将字符串str插入此字符序列指定位置中 </p>
<p>int length( ) 确定 StringBuffer 对象的长度</p>
<p>void setCharAt(int pos, char ch) 使用 ch 指定的新值设置 pos 指定的位置上的字符</p>
<p>String toString( ) 转换为字符串形式</p>
<p>StringBuffer reverse( ) 反转字符串 </p>
<p>StringBuffer delete(int start, int end) 删除调用对象中从 start 位置开始直到 end 指定的索引 – 1 位置的字符序列</p>
<p>StringBuffer deleteCharAt(int pos) 将删除 pos 指定的索引处的字符</p>
<p>StringBuffer replace(int start, int end, String s) 使用一组字符替换另一组字符。将用替换字符串从 start 指定的位置开始替换，直到 end 指定的位置结束</p>
<h2 id="8-3-StringBuilder"><a href="#8-3-StringBuilder" class="headerlink" title="8.3 StringBuilder"></a>8.3 StringBuilder</h2><p>StringBuilder与StringBuffer的用法几乎完全一致</p>
<p>StringBuffer是线程安全的，StringBuilder是线程不安全的，StringBuilder性能要比StringBuffer要好。</p>
<h1 id="9-Date、SimpleDateFormat、Calendar"><a href="#9-Date、SimpleDateFormat、Calendar" class="headerlink" title="9. Date、SimpleDateFormat、Calendar"></a>9. Date、SimpleDateFormat、Calendar</h1><h2 id="9-1-Date"><a href="#9-1-Date" class="headerlink" title="9.1 Date"></a>9.1 Date</h2><p>位于j<strong>ava.util.Date下</strong>（sql语包也有Date类，位于java.sql.Date, import时要注意）。</p>
<p>Date类表示特定的瞬间，精确到毫秒。Date包含时间和日期两种信息。</p>
<h3 id="9-1-1-构造方法"><a href="#9-1-1-构造方法" class="headerlink" title="9.1.1 构造方法"></a>9.1.1 构造方法</h3><p>Date(long dt)　使用自1970年1月1日00:00:00 GMT以来的指定毫秒数创建一个Date实例</p>
<p>Date() 使用系统当前的时间创建一个Date实例。</p>
<h3 id="9-1-2-常用方法"><a href="#9-1-2-常用方法" class="headerlink" title="9.1.2 常用方法"></a>9.1.2 常用方法</h3><table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public long getTime()</td>
<td>返回自  1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</td>
</tr>
<tr>
<td>public boolean after(Date when)</td>
<td>测试此日期是否在指定日期之后</td>
</tr>
<tr>
<td>public boolean before(Date when)</td>
<td>测试此日期是否在指定日期之前。</td>
</tr>
<tr>
<td>public int compareTo(Date anotherDate)</td>
<td>比较两个日期的顺序。</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>比较两个日期的相等性</td>
</tr>
</tbody></table>
<h2 id="9-2-SimpleDateFormat"><a href="#9-2-SimpleDateFormat" class="headerlink" title="9.2 SimpleDateFormat"></a>9.2 SimpleDateFormat</h2><p>SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）。</p>
<h3 id="9-2-1-构造方法"><a href="#9-2-1-构造方法" class="headerlink" title="9.2.1 构造方法"></a>9.2.1 构造方法</h3><p>public SimpleDateFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。</p>
<h2 id="9-2-2-Date格式"><a href="#9-2-2-Date格式" class="headerlink" title="9.2.2 Date格式"></a>9.2.2 Date格式</h2><p>yyyy 年</p>
<p>MM 月</p>
<p>dd 日</p>
<p>hh 12小时制</p>
<p>HH 24小时制</p>
<p>mm 分</p>
<p>ss 秒</p>
<h3 id="9-2-3-常用方法"><a href="#9-2-3-常用方法" class="headerlink" title="9.2.3 常用方法"></a>9.2.3 常用方法</h3><p>public final String format(Date date) 将一个 Date 格式化为日期&#x2F;时间字符串</p>
<p>public Date parse(String source) throws ParseException 从给定字符串的开始解析文本，以生成一个日期。</p>
<h2 id="9-3-Calendar"><a href="#9-3-Calendar" class="headerlink" title="9.3 Calendar"></a>9.3 Calendar</h2><p>Calendar 主要用于完成日期字段之间相互操作的功能。即可以设置和获取日期数据的特定部分。</p>
<h3 id="9-3-1-获得Calendar实例"><a href="#9-3-1-获得Calendar实例" class="headerlink" title="9.3.1 获得Calendar实例"></a>9.3.1 获得Calendar实例</h3><p>Calendar类(日历)是一个抽象基类，对象只能通过内部提供的方法，获得Calendar子类的对象。</p>
<p>Calendar.getInstance();</p>
<h3 id="9-3-2-常用方法"><a href="#9-3-2-常用方法" class="headerlink" title="9.3.2 常用方法"></a>9.3.2 常用方法</h3><p>public int get(int field) 根据给定的日历字段获得当前时间中相应字段的值。</p>
<p>public void set(int field, int value) 将指定的日历字段设置为给定的值</p>
<p>public void add(int field, int amount) 根据日历的规则，为给定的日历字段添加或减去指定的时间量。</p>
<p>public final Date getTime() 返回一个表示此 Calendar 时间值的 Date 对象</p>
<p>public final void setTime(Date date) 使用给定的 Date 设置此 Calendar 的时间</p>
<p>public long getTimeInMillis() 返回此 Calendar 的时间毫秒值</p>
<h1 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10. 正则表达式"></a>10. 正则表达式</h1><p>RegEx 是正则表达式的缩写，使用正则表达式可以对某个文本进行模式匹配。</p>
<h2 id="10-1-Pattern-类"><a href="#10-1-Pattern-类" class="headerlink" title="10.1  Pattern 类"></a>10.1  Pattern 类</h2><p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;.bc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">matche</span> <span class="operator">=</span> Pattern.matches(regex, <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>


<h2 id="10-2-正则规则"><a href="#10-2-正则规则" class="headerlink" title="10.2 正则规则"></a>10.2 正则规则</h2><p><strong>元字符注意：使用时候前面需要加上转义字符\， 比如\d</strong></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除 “\n” 之外的任何单个字符。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9**]’。**</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。</td>
</tr>
</tbody></table>
<p><strong>前后缀</strong></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串的开始位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位置。</td>
</tr>
</tbody></table>
<p><strong>量词</strong></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式0次或多次。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。</td>
</tr>
<tr>
<td>{<strong>n</strong>}</td>
<td><strong>n</strong> 是一个非负整数。匹配确定的 <strong>n</strong> 次。</td>
</tr>
<tr>
<td>{<strong>n</strong>,}</td>
<td><strong>n</strong> 是一个非负整数。至少匹配<strong>n</strong> 次。</td>
</tr>
<tr>
<td>{<strong>n</strong>,<strong>m</strong>}</td>
<td><strong>m</strong> 和 <strong>n</strong> 均为非负整数，其中<strong>n</strong> &lt;&#x3D; <strong>m</strong>。最少匹配 <strong>n</strong> 次且最多匹配 <strong>m</strong> 次。</td>
</tr>
</tbody></table>
<p><strong>范围</strong></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[<strong>xyz</strong>]</td>
<td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td>[<strong>x,y,z</strong>]</td>
<td>字符集合。匹配所包含的任意一个数字。例如， ‘[1,2,5]’ 可以匹配 1,2,5。</td>
</tr>
<tr>
<td>[^<strong>xyz</strong>]</td>
<td>负值字符集合。匹配未包含的任意字符。</td>
</tr>
<tr>
<td>[<strong>a-z</strong>]</td>
<td>小写字符范围。匹配指定范围内的任意字符。</td>
</tr>
<tr>
<td>[^<strong>a-z</strong>]</td>
<td>负值字符范围。匹配任何不在指定范围内的任意字符。</td>
</tr>
<tr>
<td>[<strong>A-Z</strong>]</td>
<td>大写字符范围。匹配指定范围内的任意字符。</td>
</tr>
<tr>
<td>[<strong>A-z</strong>]</td>
<td>大写和小写字符范围。匹配指定范围内的任意字符。</td>
</tr>
<tr>
<td>[<strong>0-9</strong>]</td>
<td>0-9的数字范围。匹配指定范围内的任意数字。例如， ‘[1-5]’ 可以匹配 1,2,3,4,5。</td>
</tr>
</tbody></table>
<p>- [abc][1,2,3]: 其中任意一个</p>
<p>- [a-e][2-5]: 范围内的任意一个</p>
<p>- [^abc][^a-e]: 非  </p>
<h2 id="10-3-Matcher-类"><a href="#10-3-Matcher-类" class="headerlink" title="10.3 Matcher 类"></a>10.3 Matcher 类</h2><p>Matcher 对象是对输入字符串进行解释和匹配操作的。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
<p>&#x2F;&#x2F; 创建一个模式对象</p>
<p>Pattern compile &#x3D; Pattern.compile(“\d”);</p>
<p>&#x2F;&#x2F; 创建字符串匹配器</p>
<p>Matcher matcher &#x3D; compile.matcher(“abc123aa”);</p>
<p>public boolean find() 尝试查找与该模式匹配的输入序列的下一个子序列。</p>
<p>public boolean find(int start）重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</p>
<p>public String replaceAll(String replacement) 替换模式与给定替换字符串相匹配的输入序列的每个子序列。</p>
<p>public String replaceFirst(String replacement) 替换模式与给定替换字符串匹配的输入序列的第一个子序列。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>MYSQL2</title>
    <url>/2024/10/05/MYSQL2/</url>
    <content><![CDATA[<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><span id="more"></span>
<h1 id="查看表中描述"><a href="#查看表中描述" class="headerlink" title="查看表中描述"></a>查看表中描述</h1><pre><code>desc tablename;
</code></pre>
<h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><pre><code>create 建表规范：
    1.表名字 一定是英文 不要写中文  汉语拼音
    2.建表风格
        1.主键 使用表中第一个字段使用自增主键 本身没有任何 业务意义
    3.字段的注释
</code></pre>
<p>业务字段<br>非业务字段:<br>    1.表创建表用户 vs 更新表用户<br>    2.主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table user_info2(</span><br><span class="line">	id int(3) not null  auto_increment,</span><br><span class="line">	name varchar(10) COMMENT &#x27;用户名称&#x27;,</span><br><span class="line">	age int(3),</span><br><span class="line">	create_user varchar(10),</span><br><span class="line">	create_time timestamp not null default current_timestamp,</span><br><span class="line">	update_user varchar(10),</span><br><span class="line">	update_time  timestamp not null default current_timestamp on update current_timestamp</span><br><span class="line">	,primary key(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]</span><br><span class="line">    [INTO] tbl_name</span><br><span class="line">    [(col_name [, col_name] ...)]</span><br><span class="line">    &#123;VALUES | VALUE&#125; (value_list) [, (value_list)] ...</span><br><span class="line">    [ON DUPLICATE KEY UPDATE assignment_list]</span><br><span class="line">insert into user_info (name,age) VALUES(&#x27;zs&#x27;,18),(&#x27;ls&#x27;,20);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into user_info (name,age) VALUES(&#x27;zs01&#x27;,18),(&#x27;ls01&#x27;,20);</span><br></pre></td></tr></table></figure>
<p>NULL: 空值<br>    ‘’ ‘null’ ‘NULL’</p>
<h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE [LOW_PRIORITY] [IGNORE] table_reference</span><br><span class="line">    SET assignment_list</span><br><span class="line">    [WHERE where_condition]</span><br><span class="line">    [ORDER BY ...]</span><br><span class="line">    [LIMIT row_count]</span><br><span class="line">where 过滤</span><br><span class="line">update user_info set age=&#x27;20&#x27;; =》 对整张表</span><br><span class="line">update user_info set age=&#x27;20&#x27; where name=&#x27;zs&#x27; ; 对某条数据</span><br><span class="line"></span><br><span class="line">update 语句 注意： where</span><br></pre></td></tr></table></figure>
<h1 id="删除一条数据"><a href="#删除一条数据" class="headerlink" title="删除一条数据"></a>删除一条数据</h1><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name</span><br><span class="line">    [PARTITION (partition_name [, partition_name] ...)]</span><br><span class="line">    [WHERE where_condition]</span><br><span class="line">    [ORDER BY ...]</span><br><span class="line">    [LIMIT row_count]</span><br></pre></td></tr></table></figure>
</code></pre>
<p>delete from user_info where id&#x3D;1;<br>注意：<br>    delete 也要考虑 是否加where</p>
<p>insert into user_info (name,age) VALUES(‘zs’,18),(‘ls’,20);<br>insert into user_info (name,age) VALUES(‘aa’,10),(‘01’,10);<br>insert into user_info (name,age) VALUES(‘bb’,11),(‘02’,20);<br>insert into user_info (name,age) VALUES(‘vv’,12),(‘03’,30);<br>insert into user_info (name,age) VALUES(‘dd’,13),(‘04’,21);</p>
<p>insert into user_info (name,age) VALUES(‘zs’,19),(‘zs’,21);</p>
<h1 id="表的字符集："><a href="#表的字符集：" class="headerlink" title="表的字符集："></a>表的字符集：</h1><pre><code>udf8 
    Incorrect string value: &#39;\xE5\xAD\x90\xE8\x88\xAA...&#39; for column &#39;name
mysql 5.7版本 默认建表字符集 ：latin1
解决：修改字符集 、建表直接指定字符集 utf8
</code></pre>
<h1 id="6-删除表"><a href="#6-删除表" class="headerlink" title="6.删除表"></a>6.删除表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	drop table user_info;</span><br><span class="line"></span><br><span class="line">	CREATE TABLE `user_info` (</span><br><span class="line">  `id` int(3) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(10) DEFAULT NULL,</span><br><span class="line">  `age` int(3) DEFAULT NULL,</span><br><span class="line">  `create_user` varchar(10) DEFAULT NULL,</span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `update_user` varchar(10) DEFAULT NULL,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<h1 id="7-其他语法"><a href="#7-其他语法" class="headerlink" title="7.其他语法"></a>7.其他语法</h1><p>1.where  过滤条件<br>    1. &gt;<br>    2.&lt;<br>    3. &#x3D;<br>    4. and or in not in<br>mysql&gt; select * from user_info where age &gt; 18;<br>select * from user_info where name&#x3D;’子航01’;<br>mysql&gt; select *  from user_info where name&#x3D;’zs’ and age&gt;18;<br>mysql&gt; select *  from user_info where age&gt;20 or name&#x3D;’zs’;</p>
<p>产品给你 1000个数据值  in<br>select *  from user_info where name&#x3D;’zs’ or name &#x3D; ‘ls’ or name &#x3D;”ww”<br>select *  from user_info where name in (‘zs’,’ls’,’ww’);<br>    not in<br>select *  from user_info where name not in (‘zs’,’ls’,’ww’);</p>
<h1 id="order-by-排序语法"><a href="#order-by-排序语法" class="headerlink" title="order by 排序语法"></a>order by 排序语法</h1><pre><code>mysql&gt; select *  from user_info order by age;

 order by column [asc | desc] ,...

1.默认是升序 
2. asc desc 降序 
</code></pre>
<p>mysql&gt; select *  from user_info order by age ,name desc;</p>
<h1 id="like语法-模糊查询"><a href="#like语法-模糊查询" class="headerlink" title="like语法 模糊查询"></a>like语法 模糊查询</h1><pre><code>1.like  rlike regexp  正则表达式【了解】
    1.% 模糊 
    2.占位符 _
</code></pre>
<p>mysql&gt; select *  from user_info where name like ‘%z%’;<br>mysql&gt; select *  from user_info where name like “_s%”;</p>
<pre><code>insert into user_info (name) VALUES(&#39;zihsssg04&#39;);
insert into user_info (name) VALUES(&#39;zshsssg04&#39;);
insert into user_info (name) VALUES(&#39;zshsssg04&#39;);
insert into user_info (name) VALUES(&#39;zshsssg04&#39;);
</code></pre>
<p>需求：<br>    1.name 字母开头是y<br>select  *  from user_info where name like “y%”;<br>    2.name 字母结尾是1<br>select  *  from user_info where name like “%1”;<br>    3.name 含有字母h<br>select  *  from user_info where name like “%h%”;<br>    4.name查询第3个字母是h的数据<br>select  *  from user_info where name like “__h%”;</p>
<h1 id="合并表"><a href="#合并表" class="headerlink" title="合并表"></a>合并表</h1><pre><code>1.union  去重
2.union all  不去重
</code></pre>
<p>create table a(id int(3),name varchar(4));<br>create table b(id int(3),name varchar(4));</p>
<p>insert into a values(1,’zs’);<br>insert into b values(1,’zs’);<br>insert into b values(2,’ls’);</p>
<p>1.union</p>
<p>select *  from a<br>union<br>select *  from b;</p>
<p>2.union all<br>select *  from a<br>union  all<br>select *  from b;</p>
<h1 id="null"><a href="#null" class="headerlink" title="null"></a>null</h1><pre><code>数据清洗 
    1.过滤null 
        is null 
        is not null 
</code></pre>
<p>select *  from user_info where age is null;</p>
<pre><code>    2.null数据进行 【数据转换】
    update 
</code></pre>
<p>数据分析时候 ：<br>    delte 、update </p>
<p>函数：<br>    处理 null的函数：<br>        1.coalesce()<br>        2.ifnull</p>
<p>select<br>id<br>,name<br>,coalesce(age,0) as age_alias<br>,create_user<br>,create_time<br>,update_user<br>,update_time<br>from user_info</p>
<p>select<br>id<br>,name<br>,ifnull(age,0) as age_alias<br>,create_user<br>,create_time<br>,update_user<br>,update_time<br>from user_info</p>
<h1 id="聚合函数：-指标"><a href="#聚合函数：-指标" class="headerlink" title="聚合函数： 指标"></a>聚合函数： 指标</h1><pre><code>多行数据按照一定规则 进行聚合为一行 
sum max min avg count 
理论上：
    聚合后的行数 &lt;= 聚合前的行数
</code></pre>
<p>insert into user_info (name,age) values(“zs”,10);<br>insert into user_info (name,age) values(“zs”,11);<br>insert into user_info (name,age) values(“zs”,12);<br>insert into user_info (name,age) values(“ls”,10);<br>insert into user_info (name,age) values(“ls”,20);<br>insert into user_info (name,age) values(“ls”,30);<br>insert into user_info (name,age) values(“ww”,30);</p>
<pre><code>1.聚合函数 
select 
sum(age) as age_sum,
max(age) as age_max
,min(age) as age_min
,avg(age) as age_avg
,count(age) as cnt
from user_info

2.分组语法
</code></pre>
<p>词频统计：<br>    wordcount </p>
<pre><code>x 
y
y
z 
</code></pre>
<p>word,1<br>&#x3D;&gt;  对每个单词进行分组  分组<br>    x,&lt;1&gt;<br>    y,&lt;1,1&gt;<br>    z,&lt;1&gt;<br>&#x3D;&gt; 聚合 sum<br>    x,1<br>    y,1+1 &#x3D;2<br>    z,1</p>
<pre><code>group by  column...
</code></pre>
<p>需求：<br>    按照name进行分组，求每组的平均年龄</p>
<p>分组聚合</p>
<p>select<br>name,<br>avg(age) as age_avg<br>from user_info<br>group by name</p>
<pre><code>需求： 
    user_info 各个name的最大年龄、最小年龄、以及人数？
</code></pre>
<p>select<br>name,<br>max(age) as age_max,<br>min(age) as age_min,<br>count(age) as cnt<br>from user_info<br>group by name </p>
<p>分组聚合:注意：<br>    1.select 字段 和  group by 字段 要对应 【非聚合函数字段】</p>
<p>select<br>name,<br>id,<br>max(age) as age_max,<br>min(age) as age_min,<br>count(age) as cnt<br>from user_info<br>group by name ,id</p>
<pre><code>维度不一样： 
    1.
        维度： name 
        指标：最大年龄、最小年龄、以及人数
    2. 
         维度： name、id 
         指标：最大年龄、最小年龄、以及人数
</code></pre>
<p>select<br>name,<br>max(age) as age_max,<br>avg(age) as age_avg,<br>count(age) as cnt<br>from user_info<br>group by name </p>
<p>求：<br>    上面的结果 求： age_avg 大于 18岁的 信息？<br>1.分组聚合 + having<br>select<br>name,<br>max(age) as age_max,<br>avg(age) as age_avg,<br>count(age) as cnt<br>from user_info<br>group by name<br>having age_avg &gt; 18<br>    总结：<br>        条件过滤：<br>            1.where 写在 from 后面<br>            2.having 写在 group by 后面</p>
<pre><code>上面的结果 求： age_avg 大于 18岁的 信息？
</code></pre>
<ol>
<li>子查询：<br> 查询里面 嵌套查询<br>select<br>name,<br>age_max,<br>age_avg,<br>cnt<br>from<br>(<br> select<br> name,<br> max(age) as age_max,<br> avg(age) as age_avg,<br> count(age) as cnt<br> from user_info<br> group by name<br>) as res<br>where<br> age_avg &gt;18;</li>
</ol>
<h1 id="join-多表联查"><a href="#join-多表联查" class="headerlink" title="join 多表联查"></a>join 多表联查</h1><pre><code>种类： 
    4种 广义上
内连接、左连接、右连接、全连接
</code></pre>
<p>内连接 **<br>左连接 **<br>全连接 *</p>
<p>create table a1(id int(3),name varchar(10),address varchar(20));<br>create table b1(id int(3),name varchar(10),age int(3));</p>
<p>insert into a1 values(1,’aa’,”dalian”);<br>insert into a1 values(2,’bb’,”shenyang”);<br>insert into a1 values(4,’dd’,”beijing”);<br>insert into b1 values(1,’aa’,10);<br>insert into b1 values(2,’bb’,20);<br>insert into b1 values(3,’cc’,21);</p>
<pre><code>1.内连接
join 
</code></pre>
<p>select </p>
<p>*<br>from a1 join b1<br>on a1.id &#x3D; b1.id	</p>
<p>select </p>
<p>*<br>from a1 inner join b1<br>on a1.id &#x3D; b1.id	</p>
<pre><code>2.左连接
left join 
    以左表为主 数据是全的 右表来匹配 匹配不上就是null 
</code></pre>
<p>select</p>
<p>*<br>from a1 left join b1<br>on a1.id &#x3D;b1.id;<br>    3.右连接<br>    right join<br>        以右表为主 数据是全的 左表来匹配 匹配不上就是null<br>select</p>
<p>*<br>from a1 right join b1<br>on a1.id &#x3D;b1.id;</p>
<pre><code>4.全连接 -- mysql 不支持全连接
    左表右表数据是全的，而且没有重复数据
full join 
</code></pre>
<p>select</p>
<p>*<br>from a1 left join b1<br>on a1.id &#x3D;b1.id<br>union<br>select</p>
<p>*<br>from a1 right join b1<br>on a1.id &#x3D;b1.id</p>
<h1 id="查询数据条数-显示限制"><a href="#查询数据条数-显示限制" class="headerlink" title="查询数据条数 显示限制"></a>查询数据条数 显示限制</h1><pre><code>limit 
场景： 
    1.显示 避免发生 滚屏效果

    小表 select *  from table ; 几千条数据 

    table： 100M 1PB  1TB
</code></pre>
<p>mysql: 极限 &#x3D;》 TB级别 相应速度 s级别 ms级别【添加索引】<br>    1Tb  select *  from table<br>    dba </p>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性</title>
    <url>/2024/10/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><span id="more"></span>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2024/10/04/MySQL/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><span id="more"></span>
<h1 id="使用场景？"><a href="#使用场景？" class="headerlink" title="使用场景？"></a>使用场景？</h1><pre><code>1.java开发人员 业务数据库
2.大数据组件 元数据 、结果数据 
</code></pre>
<h1 id="2-什么是mysql？"><a href="#2-什么是mysql？" class="headerlink" title="2.什么是mysql？"></a>2.什么是mysql？</h1><pre><code>1.关系型数据库： RDBMS  非关系型数据库NoSQL
    1.存储数据
    2.查询
2.类似表格
3.有行有列
</code></pre>
<h1 id="3-背景："><a href="#3-背景：" class="headerlink" title="3.背景："></a>3.背景：</h1><pre><code>处理数据 ：excel 
mysql： 
    存储数据，数据分析
    一堆类似excel的表格
</code></pre>
<h1 id="4-官网"><a href="#4-官网" class="headerlink" title="4.官网"></a>4.官网</h1><pre><code>www.mysql.com
</code></pre>
<h1 id="5-版本："><a href="#5-版本：" class="headerlink" title="5.版本："></a>5.版本：</h1><pre><code>8.x 不是主流、java团队 
5.7  it java 大数据 主流
5.6 目前公司也有
</code></pre>
<p>补充：<br>    上传下载：<br>        [root@bigdata31 software]# yum install -y lrzsz</p>
<pre><code>上传： rz 
下载 ：sz xxx
</code></pre>
<h1 id="6-部署："><a href="#6-部署：" class="headerlink" title="6.部署："></a>6.部署：</h1><pre><code>1.下载安装包  
    5.7
    安装包种类：
        rpm包 ：mysql source code =》 rpm包
            mysql-5.7.38-1.el7.x86_64.rpm-bundle.tar

        tar包：mysql source code +开发加的mysql代码 =》 编译打包生成 tar包

            mysql-5.7.38-el7-x86_64.tar.gz

准备好了： 
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="number">2.</span>安装部署</span><br><span class="line">		<span class="number">1.</span>上传mysql 安装包</span><br><span class="line">			[root<span class="meta">@bigdata31</span> software]# ll</span><br><span class="line">			total <span class="number">595272</span></span><br><span class="line">			-rw-r--r--. <span class="number">1</span> root root <span class="number">609556480</span> Aug <span class="number">26</span>  <span class="number">2021</span> mysql-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm-bundle.tar</span><br><span class="line">			[root<span class="meta">@bigdata31</span> software]# pwd</span><br><span class="line">			/root/software</span><br><span class="line"></span><br><span class="line">		<span class="number">2.</span>部署 </span><br><span class="line">			<span class="number">1.</span>解压</span><br><span class="line">			[root<span class="meta">@bigdata31</span> software]# tar -xvf ./mysql-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm-bundle.tar </span><br><span class="line">mysql-community-embedded-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line">mysql-community-libs-compat-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line">mysql-community-devel-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line">mysql-community-embedded-compat-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line">mysql-community-libs-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line">mysql-community-test-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line">mysql-community-common-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line">mysql-community-embedded-devel-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line">mysql-community-client-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line">mysql-community-server-<span class="number">5.7</span><span class="number">.28</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<pre><code>2.安装 
    1.卸载 mariadb 相关的东西
    [root@bigdata31 software]# rpm -qa | grep mariadb
</code></pre>
<p>mariadb-libs-5.5.56-2.el7.x86_64<br>        [root@bigdata31 software]# rpm -e –nodeps mariadb-libs-5.5.56-2.el7.x86_64<br>[root@bigdata31 software]# rpm -qa | grep mariadb</p>
<pre><code>rpm -ivh mysql-community-common-5.7.28-1.el7.x86_64.rpm 
注意： 
    package mariadb-libs conflicts with 
</code></pre>
<p>rpm -ivh mysql-community-libs-5.7.28-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-libs-compat-5.7.28-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-client-5.7.28-1.el7.x86_64.rpm<br>rpm -ivh mysql-community-server-5.7.28-1.el7.x86_64.rpm</p>
<pre><code>3.有一个 配置文件 管控mysql 
    /etc/my.cnf

    mysql运行日志文件：log-error=/var/log/mysqld.log
4.初始化mysql 
        mysqld --initialize --user=mysql
    
     A temporary password is generated for root@localhost: rfnYYHj0jc,R

5.启动mysql 
    systemctl start mysqld 
    mysql 可以对外提供服务：
        port： 3306
6.登录mysql 使用
    mysql -uroot -prfnYYHj0jc,R

7.修改mysql 软件 root用户 密码
    set password = password(&#39;123456&#39;);
8.赋予权限 
    flush privileges;

补充： 
    卸载： 
        1.mysql 停掉 
            systemctl stop mysqld 
        2.mysql卸载 
            rpm -qa | grep mysql
            rpm -qa | grep mysql | xargs -n1 rpm -e --nodeps 
        3.linux存储目录删掉 
            find / -name &quot;*mysql*&quot; 
            注意：/sys/
        4.重装
    
    mysql 全部卸载重装


    shift + alt =&gt;多行编辑
    alt + tab 
    rm -rf xx 
</code></pre>
<p>mysql 数据库：<br>       excel 表格<br>       win：<br>       	 文件夹：<br>            一堆表格</p>
<p>MySQL:<br>    数据库：&#x3D;》文件夹 database<br>        一堆表格 table</p>
<p>远程登录工具：<br>    navcat 【选择】<br>    sqlyog<br>    dbvear工具 【选择】</p>
<pre><code>root@localhost: 123456
    只允许 当前机器登录
root@%: 123456
</code></pre>
<p>远程登录访问：<br>    1.修改 mysql 登录 运行用户的ip &#x3D;》 任意ip </p>
<p>mysql语法：【了解】<br>    1.查看数据库<br>        show databases;<br>    2.切换数据库<br>        use mysql;<br>    3.查看库下面有哪些表<br>        show tables;<br>    4.查看表中数据<br>    select host,user<br>    from user;<br>    5.修改表中数据<br>    update mysql.user set  host&#x3D;”%” where user&#x3D;”root”;<br>    6.刷新权限<br>    flush privileges; </p>
<p>基本语法：<br>    1.sql进行开发<br>        sql类型：<br>            ddl 数据定义语言 ：create drop  alter<br>            dml 数据操作语言 : insert select update delete<br>            dcl 数据控制语言 :grant [了解]<br>2.查看数据库<br>    SHOW {DATABASES | SCHEMAS}<br>    [LIKE ‘pattern’ | WHERE expr]</p>
<p>{} 必选参数 | 可选<br>[] 可选<br>    SHOW DATABASES;</p>
<p>mysql&gt; SHOW DATABASES;<br>+——————–+<br>| Database           |<br>+——————–+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+——————–+<br>4 rows in set (0.00 sec)</p>
<p>3.切换数据库<br>    use dbname;</p>
<p>4.查看数据库下面的表<br>    SHOW [FULL] TABLES<br>    [{FROM | IN} db_name]<br>    [LIKE ‘pattern’ | WHERE expr]<br>    SHOW TABLES;</p>
<p>mysql&gt; show tables FROM sys;</p>
<p>5.创建数据库<br>    CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name<br>    [create_option] …</p>
<p>create_option: [DEFAULT] {<br>    CHARACTER SET [&#x3D;] charset_name<br>  | COLLATE [&#x3D;] collation_name<br>}</p>
<p>CREATE DATABASE bigdata;</p>
<p>6.创建表<br>    excel ： </p>
<pre><code>字段：column : 
        1.名称
        2.字段类型
</code></pre>
<p>常用字段类型：<br>    数值类型：<br>        整数：<br>            int 整型<br>            long 长整型<br>        小数：<br>            float 单精度<br>            double 双精度<br>            decimal 小数 &#x3D;》 跟钱挂钩的<br>    字符串：<br>        char 字节  长度 0-255  bigdataxxxxxxx 255<br>        varchar 字符串 长度范围<br>    日期：<br>        date  日期： YYYY-MM-DD<br>        time 时间 ： HH:mm:SS<br>        datetime 年月日时分秒 ： YYYY-MM-DD HH:mm:SS<br>        timestamp 年月日时分秒【时间戳】:YYYY-MM-DD HH:mm:SS</p>
<p>列的名字、字段的名字<br>mysql&gt; CREATE TABLE user_table(<br>    -&gt; id int(3),<br>    -&gt; name varchar(10),<br>    -&gt; age int(3)<br>    -&gt; );<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; show tables;<br>+——————-+<br>| Tables_in_bigdata |<br>+——————-+<br>| user_table        |<br>+——————-+<br>1 row in set (0.00 sec)</p>
<p>7.表中插入数据 </p>
<p>INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]<br>    [INTO] tbl_name<br>    [(col_name [, col_name] …)]<br>    {VALUES | VALUE} (value_list) [, (value_list)] …<br>    [ON DUPLICATE KEY UPDATE assignment_list]</p>
<p>INSERT into user_table (id,name,age)VALUES (1,’zhangsan’,10);</p>
<p>8.查看数据</p>
<ul>
<li>表示所有字段</li>
</ul>
<p>select *<br>from user_table;</p>
<p>select name,age from user_table;</p>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL3</title>
    <url>/2024/10/06/MYSQL3/</url>
    <content><![CDATA[<h1 id="MYSQL3"><a href="#MYSQL3" class="headerlink" title="MYSQL3"></a>MYSQL3</h1><span id="more"></span>
<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc:"></a>jdbc:</h1><pre><code>java
db 
connction
</code></pre>
<h1 id="maven部署："><a href="#maven部署：" class="headerlink" title="maven部署："></a>maven部署：</h1><pre><code>1.下载 解压 

2.配置环境变量
    MAVEN_HOME=D:\sxwang\app\apache-maven-3.8.1
    PATH=%MAVEN_HOME%\bin
3.cmd 
</code></pre>
<h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><pre><code>1.创建maven 项目 
2.src =》 开发代码目录
3.pom.xml : 
    添加第三方依赖包
</code></pre>
<h1 id="如何获取mysql连接？"><a href="#如何获取mysql连接？" class="headerlink" title="如何获取mysql连接？"></a>如何获取mysql连接？</h1><pre><code>1.url ： 
    mysql ip 
    mysql db 
2.mysql 用户名 
3.mysql 密码
</code></pre>
<h1 id="添加第三方依赖包"><a href="#添加第三方依赖包" class="headerlink" title="添加第三方依赖包:"></a>添加第三方依赖包:</h1><pre><code>mysql的驱动包： 
    maven进行第三方jar管理： 
        mysql-

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.28&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>问题：<br>    1.pom.xml:<br>        可能正在下载第三方jar  </p>
<pre><code>2.更改本地maven 仓库地址 
    D:\sxwang\app\apache-maven-3.8.1\conf\settings.xml
</code></pre>
<h1 id="操作mysql"><a href="#操作mysql" class="headerlink" title="操作mysql:"></a>操作mysql:</h1><pre><code>1.crud 
 insert、delete、update、select 

    获取连接：
        1.准备sql
            1. insert、delete、update
            2.select
        2.执行sql
            1. insert、delete、update
            2.select
</code></pre>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL:"></a>MySQL:</h1><pre><code>    1.ddl: 
        1.alter: 
            1.db 
                ALTER &#123;DATABASE | SCHEMA&#125; [db_name]
                alter database bigdata CHARACTER SET = &#39;utf8&#39;;
            2.table: 
                1.添加字段
                    alter table a1 add column column_add varchar(20) after address;
                    alter table a1 add column column_add01 varchar(20) first ;
                2.修改字段：
                    1.name 
                    2.type 
                    alter table a1 CHANGE COLUMN column_add01 column_add01 int(3);
                3.删除字段：【一般不会发生】 
                    alter table a1 DROP  column_add01;

        2.truncate  =&gt; 清空表
            delete
                1.truncate table a1;

        3.create table 
            1.CREATE TABLE ... LIKE Statement =&gt; 只拷贝 表结构
                eg:
                    CREATE TABLE emp_dev LIKE emp;
            2.CREATE TABLE ... SELECT Statement =》 比较多 临时查询的结果 临时生成一个表
                ctas：
                    CREATE TABLE new_tbl [AS] SELECT * FROM orig_tbl;
                create table emp_dev01 as select ename,job from emp;
```		
    2.dml
        1.insert 
        insert into table_name [(columns)]values(value_list,...)

        a b 表结构是一样： 
            需求： 
                两张表 ， a有数据，b没有数据 
                把a表数据导入b数据？ 
            
            insert into b (name,age) 
            select name,age from a;

            emp a1  
            insert into a1(name,address)
            select ename,job from emp;




</code></pre>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
  </entry>
  <entry>
    <title>git</title>
    <url>/2024/10/06/git/</url>
    <content><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><span id="more"></span> 
<h1 id="git是什么？"><a href="#git是什么？" class="headerlink" title="git是什么？"></a>git是什么？</h1><pre><code>官网地址： 
    https://git-scm.com/

distributed version control system
</code></pre>
<h1 id="version-control-system？"><a href="#version-control-system？" class="headerlink" title="version control system？"></a>version control system？</h1><pre><code> Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. 
 记录文件变化的 并且 之后可以指定版本进行恢复

1.论文： 
    1.xxx_v1.doc 
    2.xxx_v2.doc 
    ...
    xxx_最终版.doc 

2.种类： 
    Local Version Control Systems： copy files into another directory
        优点：
            so simple
        缺点： 
            error prone 
            1.代码集成效率低下

    Centralized Version Control Systems 集中式版本控制系统： 
        解决： 代码集成效率低下 
            多人协同开发的问题
        问题：
            single point 单点故障

    Distributed Version Control Systems： 
            解决： 多人协同开发 单点故障
        1.clients

        2.server

    git： 
        1.efficiency.
        2.performance.
        3.分支操作、文件备份、定制工作流程
</code></pre>
<h1 id="文件版本控制："><a href="#文件版本控制：" class="headerlink" title="文件版本控制："></a>文件版本控制：</h1><pre><code>1.本地仓库
2.远程仓库
</code></pre>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><pre><code>1.下载
2.安装
3.使用： 
    1.git 软件 工具
        1.可视化界面的方式进行操作 =》 git原理
        2.git 命令操作 =》 linux 命令差不多

        linux 内核 林纳斯 
        git
</code></pre>
<h1 id="查看git版本"><a href="#查看git版本" class="headerlink" title="查看git版本"></a>查看git版本</h1><p>$ git -v<br>git version 2.38.0.windows.1</p>
<p>使用： 版本控制<br>    1.使用的前的配置 </p>
<pre><code>-- 要配置我们的项目开发人员的信息
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;zhangsan&quot;</span><br><span class="line">git config --global user.email &quot;zhangsan@qq.com&quot;</span><br><span class="line">	1.设置git参数 =》 本地仓库</span><br><span class="line">usage: git config [&lt;options&gt;]</span><br><span class="line"></span><br><span class="line">Config file location</span><br><span class="line">    --global              use global config file  --对当前用户 所有仓库都有效</span><br><span class="line">    --system              use system config file  -- 对系统所有登录用户有效</span><br><span class="line">    --local               use repository config file -- 对某个仓库有效</span><br></pre></td></tr></table></figure>
<pre><code>思考： 
    单单对某一个项目来说 上面哪个参数 有限级高？
        --local
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config [options]</span><br><span class="line">option...</span><br><span class="line">查看配置参数： </span><br><span class="line">	git config --list </span><br><span class="line">	git config --list --global</span><br><span class="line">	git config --list --local</span><br></pre></td></tr></table></figure>
<p>1.创建仓库<br>    项目：开发的代码文件<br>    仓库：本地仓库 用于进行文件的版本控制的</p>
<pre><code>git init: 
    1.创建一个仓库
    2.重新初始化一个 以及存在的仓库
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init [-q | --quiet] [--bare] [--template=&lt;template-directory&gt;]</span><br><span class="line">          [--separate-git-dir &lt;git-dir&gt;] [--object-format=&lt;format&gt;]</span><br><span class="line">          [-b &lt;branch-name&gt; | --initial-branch=&lt;branch-name&gt;]</span><br><span class="line">          [--shared[=&lt;permissions&gt;]] [&lt;directory&gt;]</span><br><span class="line">	</span><br><span class="line">	git init [&lt;directory&gt;]</span><br></pre></td></tr></table></figure>

<p>项目：《&#x3D;》 本地仓库 【一个项目 对应一个本地仓库】<br>    1.存在：<br>        cd 项目目录<br>        git init<br>    2.不存在：<br>         git init <project_name><br>         git init test01：<br>         	1.创建一个项目 test01<br>            2. test01目录下下面 创建一个本地仓库 </p>
<pre><code>    .git 文件夹 本地仓库
</code></pre>
<p>使用<br>    git 管理版本控制的工作流程：<br>        工作区： 项目目录<br>        暂存区： 临时存储文件的地方 可以进行撤回<br>        本地仓库：版本控制</p>
<p> 入门：<br>    1.vim 1.log<br>    2.git add 1.log  &#x3D;&gt; 添加到暂存区<br>    3.git commit -m “Add 1.log” &#x3D;&gt; 添加到 本地仓库<br>    4.git log 查看本地仓库历史 ：当前项目的 commit历史</p>
<p>git commit  -m <msg></p>
<pre><code>总结： 
    本地仓库 ： 
        如何进行版本控制？
            commit 进行区分版本的

切换版本： 可以使用
    git reset --hard [&lt;commit&gt;]

    git reset --hard d7db6e
</code></pre>
<p>了解：<br>     git log –reflog</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2024/10/03/Linux/</url>
    <content><![CDATA[<h1 id="Linux概述："><a href="#Linux概述：" class="headerlink" title="Linux概述："></a>Linux概述：</h1><span id="more"></span>
<pre><code>1.操作系统
2.linux 
3.版本：
    Ubuntu 、 centos、debian、redhat。。。

    win： 大版本 
    小版本 

    centos ： 
        6.x  
        7.x  主流
        8.x
</code></pre>
<h1 id="2-为什么要使用Linux？"><a href="#2-为什么要使用Linux？" class="headerlink" title="2.为什么要使用Linux？"></a>2.为什么要使用Linux？</h1><pre><code>1.生产上： 
    大数据组件基于linux 进行开发部署
2.java 算法 
</code></pre>
<h1 id="3-部署linux系统"><a href="#3-部署linux系统" class="headerlink" title="3.部署linux系统"></a>3.部署linux系统</h1><pre><code>1.win： 
    1.虚拟机 要求： 
        1.你的winwow 配置 内存 8G 
        2. 伤window 磁盘 

    2.云主机 ： 
        1.云厂商 ： 
            阿里云、腾讯云、华为云、京东云
            1.3个月 69
            2.按需分配 
</code></pre>
<h1 id="4-虚机机-部署linux系统："><a href="#4-虚机机-部署linux系统：" class="headerlink" title="4.虚机机 部署linux系统："></a>4.虚机机 部署linux系统：</h1><pre><code>win： 
    1.虚拟化的软件 ： 
        vmware 、vbox。。。
            1.linux镜像 

1.安装 vmware 
    1.注册码 =》文档里有
    2.win 不支持vmware安装 ： 
        1.bios 没有打开

2.打开vmware 
    1.关联linux镜像   =》 linux部署 
</code></pre>
<p>linux部署：<br>    1.稍后安装<br>    2. 机器的名字+路径：机器存储路径 + 存储路径<br>    3.资源：<br>        1.cpu ： 2core<br>        2.mem：4g 、2g<br>        3.df 40G<br>    4.关联linux镜像 </p>
<p>linux启动： 4g 40G<br>    centos 7.5 ：简单配置<br>        1.语言：<br>            中文<br>        2.软件：<br>             软件选择：带桌面安装</p>
<pre><code>    3.系统配置：
        1.kdump 关闭 =》 保护机制 
        2.网络： 
            1.网卡打开
            2.hostname
        3.磁盘划分 ： 
            1.boot =》 存放linux启动的资源 1g 
                file system =》 ext4
            2.swap: 2g
                把磁盘资源 当做 内存来使用 
            3./ 根目录 ： 
                linux全部存储空间 磁盘大小
                file system =》 ext4
</code></pre>
<p>linux系统：<br>    1.用户：<br>        root  最高权限用户 </p>
<p>远程登录访问：<br>    1.win&#x2F;mac:<br>        1.安装xshell<br>            远程登录工具：<br>                xshell、crt、finlshell 【百度搜想要的远程工具推荐】</p>
<pre><code>    2.远程登录 ： -- 打开xshell
        1.机器的ip ：192.168.10.22  【ifconfig 查看自己的ip 】
        2.用户名 root
        3.密码 123456
        4.端口 22
</code></pre>
<p>linux系统：<br>    1.层级式文件存储系统<br>        根目录 &#x2F;</p>
<p>linux命令<br>[root@bigdata22 ~]#<br>    root 默认的管理员 最大权限用户<br>    bigdata22 机器的名字<br>    ~  当前用户的 家目录 </p>
<p>1.pwd 查看当前光标所在的目录<br>[root@bigdata22 ~]# pwd<br>&#x2F;root</p>
<p>2.ls 查看光标所在的目录下面<br>    ls  显示 文件夹和文件<br>    ls -l 显示额外的信息【权限、用户用户组 大小 时间】<br>    ls -l -a 显示以.开头的文件和文件夹<br>            以.开头的文件和文件夹 隐藏文件<br>    ls -l -h 查看文件的大小</p>
<pre><code>命令帮助：
    命令 --help 

ls --help
用法：ls [选项]... [文件]...

[] 可选
... 多个

ls -l =&gt; ll 等价 别名

需求： 
    一个目录下面 有1000多个文件 查找 最新更改的文件 ？ 

ll -r -t  =&gt; ll -rt
</code></pre>
<p>3.mkdir 创建文件夹<br>    [root@bigdata22 ~]# mkdir bigdata<br>    1.并级<br>        [root@bigdata22 ~]# mkdir dir1 dir2 dir3<br>    2.串级<br>        [root@bigdata22 ~]# mkdir -p dir4&#x2F;dir5&#x2F;dir6</p>
<p>4.cd 切换目录、路径、文件夹<br>    [root@bigdata22 ~]# cd bigdata&#x2F;<br>        &#x2F;</p>
<pre><code>    路径： 
        绝对路径：光标从 根目录开始的 
            cd /root/dir2
        相对路径：光标从 当前开始
            cd ./dir2/

cd ../ 退回到上一层级目录
cd ../../

../ 
./ 当前目录

~ 当前用户的 家目录
    root 家目录 /root 
    其他用户
    xx  家目录 /home/xx

如何快速回到家目录？
    1. cd /root 
    2. cd 回车  ==&gt;推荐
    3. cd ~

cd - 回到上一次操作的目录
</code></pre>
<p>5.创建文件<br>    常用：<br>        1.touch 1.log<br>        2.vi&#x2F;vim 2.log<br>    不常用：<br>        echo “bigdata” &gt; 3.log<br>echo “bigdata” 打印</p>
<blockquote>
<p>创建或者覆盖一个文件</p>
<blockquote>
<p>追加</p>
</blockquote>
</blockquote>
<p>6.编辑文件 vi&#x2F;vim<br>    三种模式：<br>        1.命令行模式<br>        2.编辑模式<br>        3.尾行模式</p>
<pre><code>vim xx.log =&gt; 命令行模式 
按键盘 i键  =》 编辑模式
按键盘 esc键 编辑模式 =》命令行模式
按键盘 shift+; =&gt; : 键 命令行模式 =》尾行模式  输入 wq 保存退出

尾行模式： 
    w 保存
    q 退出
    ! 强制
</code></pre>
<p>7.查看文件<br>    cat  查看文件所有内容 输出到控制台<br>    more 文件内容 一页一页的 按空格 往下翻 q退出<br>    less 文件内容 一页一页的 按上下键 q退出</p>
<pre><code>    看小文件： 
        cat 
    看大文件 vim
        more less

实时查看文件新产生的内容 
    tail ： 
        -f 1.log
        -F  = -f +retry
    
    ctrl +c /  ctrl +z  中断命令

场景： 
    log： 
        日志级别 info、warn、 error
    如何定位 error信息？ 
        1.vim xxx.log  搜索 error词 ： 
            尾行模式：输入 /要找的词 
                键盘 n 查找下一个词 
                    N 找上一个词
            
            日志文件 1G 100w个 
        2.cat 
            cat vmware-vmsvc.log | grep error  &gt; error.log 
            定位 error 上下文
            cat vmware-vmsvc.log | grep -A 3 error &gt; error.log =》 error 后10行
            cat vmware-vmsvc.log | grep -B 3 error &gt; error.log =》 error 前10行
            cat vmware-vmsvc.log | grep -C 3 error &gt; ~/error.log =》 error 前后各10行
</code></pre>
<p>| 管道符 &#x3D;》上一个命令的结果 作为下一个命令的输入<br>grep 过滤 文本所在的一行</p>
<p>8.文件上传下载<br>    上传：win &#x3D;》 linux<br>    下载： linux &#x3D;》 win </p>
<pre><code>1.xshell工具 xftp
2.linux命令
    yum install -y lrzsz 
</code></pre>
<p>9.自动补全<br>    tab ：<br>        按一次  匹配的东西 就一个 自动补全<br>        按两次 把匹配东西全部匹配出来<br>10.清屏 ：<br>    clear<br>    ctrl +l</p>
<p>11.查看历史命令<br>    history<br>        1.快速执行</p>
<ol start="12">
<li><p>mv 移动  cp 复制</p>
<p>mv [选项]… 源文件… 目录<br>mv dir1 bigdata<br>cp [选项]… 源文件… 目录<br>cp  -r dir2 bigdata<br>mv 始终是一份  快<br>cp 两份		 慢</p>
<p>改名字：</p>
</li>
</ol>
<p>13.rm 删除文件或者文件夹 【高危命令】<br>    rm [选项]… 文件…<br>        有删除提示：<br>            删除文件：<br>                rm error.log<br>            删除文件夹：<br>                [root@bigdata22 ~]# rm -r dir3_blk<br>        强制删除：没有提示<br>            [root@bigdata22 ~]# rm -f 2.log<br>            [root@bigdata22 ~]# rm -r -f dir2_blk</p>
<pre><code>    rm -r -f xxx =&gt; rm -rf  xxx 

rm -rf / =&gt; 删库跑路  root 权限限制
</code></pre>
<p>14.别名 alias</p>
<pre><code>1.创建别名 
    alias aa=&quot;cd /tmp&quot;  =&gt; 仅仅是当前会话生效 

    [root@bigdata22 ~]# aa
    bash: aa: 未找到命令...
    是因为没有在 环境变量文件里面 进行配置 
</code></pre>
<p>15.环境变量：<br>    jdk &#x3D;》 path<br>    环境变量路径：[root@bigdata22 ~]# echo $PATH<br>        &#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin</p>
<pre><code>1.全局环境变量 
    /etc/profile  所有用户都可以使用

2.个人环境变量	 只能当前用户使用 其他用户 不能使用
        ~/.bashrc 【建议】
        ~/.bash_profile

3.生效环境变量 
    1.source /etc/profile
    2.重新打开一个会话

    个人：
        alias cc=&quot;cd /tmp&quot;
</code></pre>
<p>1.用户管理命令<br>    linux 用户：<br>        用户<br>        用户组</p>
<pre><code>yizi： 
    hr、财务


1.查看用户相关的命令 
[root@bigdata22 ~]# ll /usr/sbin/user*
-rwxr-x---. 1 root root 118192 11月  6 2016 /usr/sbin/useradd
-rwxr-x---. 1 root root  80360 11月  6 2016 /usr/sbin/userdel
-rwxr-x---. 1 root root 113840 11月  6 2016 /usr/sbin/usermod
2.	查看用户组相关的命令
    [root@bigdata22 ~]# ll /usr/sbin/group*
-rwxr-x---. 1 root root 65480 11月  6 2016 /usr/sbin/groupadd
-rwxr-x---. 1 root root 57016 11月  6 2016 /usr/sbin/groupdel
-rwxr-x---. 1 root root 57064 11月  6 2016 /usr/sbin/groupmems
-rwxr-x---. 1 root root 76424 11月  6 2016 /usr/sbin/groupmod

3.创建用户
[root@bigdata22 ~]# useradd uzi
</code></pre>
<p>[root@bigdata22 ~]# id uzi<br>uid&#x3D;1005(uzi) gid&#x3D;1006(uzi) 组&#x3D;1006(uzi)、</p>
<pre><code>创建一个普通用户 uzi  用户名称 uzi
也会创建一个 uzi 用户组
会把主组 设置成 uzi 
同时 也会创建一个家目录： /home/uzi

用户的信息 /etc/passwd
用户组的信息 /etc/group

4.切换用户 
    su uzi
    su - uzi 切换用户的同时 也会获得 该用户的环境变量以及执行 【推荐】

5.
    场景： 
        [root@bigdata22 ~]# useradd uzi
</code></pre>
<p>useradd：警告：此主目录已经存在。<br>不从 skel 目录里向其中复制任何文件。 &#x3D;》 提供样式 以及环境变量的文件<br>正在创建信箱文件: 文件已存在</p>
<p>[root@bigdata22 ~]# ll -a &#x2F;etc&#x2F;skel&#x2F;<br>总用量 32<br>drwxr-xr-x.   3 root root  4096 4月  11 2018 .<br>drwxr-xr-x. 135 root root 12288 11月  1 09:51 ..<br>-rw-r–r–.   1 root root    18 4月  11 2018 .bash_logout<br>-rw-r–r–.   1 root root   193 4月  11 2018 .bash_profile<br>-rw-r–r–.   1 root root   231 4月  11 2018 .bashrc<br>drwxr-xr-x.   4 root root  4096 4月  12 2022 .mozilla</p>
<p>用户样式丢失的问题？<br>    1.[root@bigdata22 uzi]# cp &#x2F;etc&#x2F;skel&#x2F;.* .&#x2F;</p>
<p>添加用户组： [root@bigdata22 ~]# groupadd bigdata</p>
<p>场景 ：<br>    uzi ： uzi<br>    1.uzi 用户 额外追加一个bigdata组？<br>    [root@bigdata22 ~]# usermod  -a -G bigdata    uzi</p>
<pre><code>2.修改主组 并添加附属组
[root@bigdata22 ~]# usermod  -a -G bigdata    uzi
[root@bigdata22 ~]# id uzi
uid=1005(uzi) gid=1006(uzi) 组=1006(uzi),1003(bigdata)
[root@bigdata22 ~]# usermod -g bigdata  uzi
[root@bigdata22 ~]# id uzi
uid=1005(uzi) gid=1003(bigdata) 组=1003(bigdata)
[root@bigdata22 ~]# usermod  -a -G uzi    uzi
[root@bigdata22 ~]# id uzi
uid=1005(uzi) gid=1003(bigdata) 组=1003(bigdata),1006(uzi)
</code></pre>
<p>2.设置用户密码<br>    passwd :<br>        1.修改当前用户的密码<br>        [root@bigdata22 ~]# passwd<br>        更改用户 root 的密码 。<br>        新的 密码：<br>        无效的密码： 密码少于 8 个字符<br>        重新输入新的 密码：<br>        passwd：所有的身份验证令牌已经成功更新。</p>
<pre><code>    2.修改其他用户密码
        [root@bigdata22 ~]# passwd uzi
        更改用户 uzi 的密码 。
        新的 密码：
        无效的密码： 密码少于 8 个字符
        重新输入新的 密码：
        passwd：所有的身份验证令牌已经成功更新。
</code></pre>
<p>3.sudo 普通用户 临时具有 使用root的最大权限 </p>
<pre><code>1.vim /etc/sudoers
    uzi ALL=(root)  NOPASSWD: ALL

2.[uzi@bigdata22 root]$ sudo ls
1.log  bigdata	dir3  dir4
</code></pre>
<p>场景：<br>    su 和 sudo 能不能一起使用？ 使用的场景是什么？<br>    能<br>    1.sudo ：切换用户<br>    2.root sudo</p>
<p>4.&#x2F;etc&#x2F;passwd<br>    1.&#x2F;sbin&#x2F;nologin  有提示<br>    2.&#x2F;usr&#x2F;bin&#x2F;false 没有提示 </p>
<pre><code>CDH平台：hadoop、hive、yarn、hdfs、flume、hue
su - yarn 
/sbin/nologin /usr/bin/false =&gt; /bin/bash
</code></pre>
<p>5.文件权限相关命令<br>    [root@bigdata22 ~]# ll<br>总用量 16<br>-rw-r–r–. 1 root root    4 10月 31 14:52 1.log<br>第一个字母： d 文件夹 - 文件 l 连接<br>后面9个字母 三个为一组 ：<br>rw- r– r–</p>
<p>r: read  读的权限 4<br>w：write 写的权限 2<br>x：执行权限       1<br>-：没权限         0</p>
<p>第一组：rw- 4+2+0&#x3D;6 代表文件或者文件夹的所属用户的 权限<br>第二组：r– 4+0+0&#x3D;4 代表文件或者文件夹的所属用户组的权限<br>第三组：r– 4+0+0&#x3D;4 代表文件或者文件夹的其他用户组的权限</p>
<p>rw-r–r– 644</p>
<p>7：4 2 1<br>6：4 2 0<br>5：4   1</p>
<p>-rwxr-xr-x  root root bigdata<br>    uzi </p>
<p>关于权限修改命令：<br>    chmod     修改文件或者文件夹的权限：<br>        chmod 640 1.log  &#x3D;》 文件<br>        chmod -R 640 &#x2F;bigdata &#x3D;&gt; 文件夹 </p>
<pre><code>chown  修改文件或者文件夹的用户和用户组
    chown [选项]... [所有者][:[组]] 文件...

    chown  uzi:uzi 1.log  =&gt; 文件 
    chown -R uzi:uzi /bigdata =&gt; 文件夹 
</code></pre>
<p>权限相关的场景？<br>    – </p>
<p>6.大小<br>    文件：ll -h  、 du -sh<br>    文件夹： du -sh</p>
<p>7.搜索文件<br>    find<br>    locate 【不用它】</p>
<p>find [-H] [-L] [-P]<br> [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path…] [expression]</p>
<p> find [path…] [expression]</p>
<pre><code>    expression： -name &quot;xxx&quot;
</code></pre>
<p>find &#x2F; -name “1.log”</p>
<p>8.vi、vim命令<br>    1.编辑文件<br>        尾行模式 wq 保存退出 正常<br>                            不正常</p>
<pre><code>ctrl +c ctrl + z 
    解决： 
        1.删除交换文件 .2.log.swp

2.error 定位信息
    log 1w多行 

    行号： 
        尾行模式 ：set nu 
        取消行号：set nonu

3.常用快捷方式 
    dd 删除当前行
    dG删除当前行 以及 以下所有行
    ndd 删除当前行 以及 以下n行

    u 撤回

    gg 跳转到第一行的第一个字母
    G 跳转到最后一个的第一个字母
    shift +$ 跳转到 行尾
    shift +^ 跳转到 行头

    i o
场景： 
    清空这个文件内容 ？ 
     gg =&gt; dG 

    清空文件内容？
        1.gg =&gt; dG	
        2.linux =》 空的文件 
            cat /dev/null &gt; 3.log	 

        echo &quot;&quot; &gt; 3.log
    
场景： 
    shell 脚本 数据文件清空的操作 根据文件字节大小判断是否清空完成
    往文件里面写入数据

    if filesize &gt; 0 then 
        不操作
    else 
        log写入数据
</code></pre>
<p>9.系统相关命令<br>    内存：free<br>        [root@bigdata22 ~]# free -h<br>    磁盘：df<br>        [root@bigdata22 ~]# df -h<br>文件系统                 容量  已用  可用 已用% 挂载点<br>&#x2F;dev&#x2F;mapper&#x2F;centos-root   56G   23G   31G   42% &#x2F;</p>
<p>添加磁盘：<br>&#x2F;dev&#x2F;vdb1   10T   23G   31G   42% &#x2F;data01<br>&#x2F;dev&#x2F;vdb2   10T   23G   31G   42% &#x2F;data02<br>&#x2F;dev&#x2F;vdb3   10T   23G   31G   42% &#x2F;data03<br>&#x2F;dev&#x2F;vdb4   10T   23G   31G   42% &#x2F;data04</p>
<pre><code>负载：top
    top - 14:20:11 up  5:28,
    2 users
    load average: 0.00, 0.01, 0.05  
                5min  10min 15min
                经验值： 
                    超过10 说明你的机器 卡卡的 
                        20
                        99=》datax 同步任务 cpu
                        重启 =》
                            1.检查硬件是否有问题 
</code></pre>
<p>10.yum &#x2F; rpm </p>
<pre><code>linux centos 软件 

yum search  xxx   -- 需要联网 
yum install xxx   -- 需要联网
</code></pre>
<p>11.通讯命令<br>    ping ip<br>    telnet ip port</p>
<pre><code>1.ip =》hostname 
 172.10.100.1  &lt;=&gt; baidu01
2.端口： 
    1-65535  =》 防火墙决定的 

a =&gt; b : 
    1.ping b_ip 网络ok 可以进行通讯的
    2.a 访问b机器某个 服务的 端口 
        telnet b_ip port 
                     9527
</code></pre>
<p>a：<br>    win<br>    ping ip  &#x3D;》 检查网络是否通畅<br>b：<br>    linux 内网ip：192.168.10.22</p>
<pre><code>22 ssh 远程登录并执行
    连不上原因： 
        1.80 没有开放 
        2.80 没有服务

    win开启telnet功能： 
        1.控制面板=》程序=》打开或关闭wins功能=》telnet客户端选中
</code></pre>
<p>补充：<br>    1.工作中 安全问题<br>        ping ip 【不允许ping】<br>        telnet ip port</p>
<pre><code>2.linux telnet ： 
    yum install -y telnet
</code></pre>
<p>12.补充命令 -》 查看linux 系统命令、某个软件shell脚本 [命令] 是否存在<br>    which<br>        which ls<br>    whereis</p>
<pre><code>1.[root@bigdata22 ~]# banzhang
    bash: banzhang: 未找到命令...
        1.命令确实没有安装
        2.安装了 没有配置环境变量

2.whereis banzhang
</code></pre>
<p>13.修改机器名字<br>    去公司 0-1 搭建服务器：<br>    hostname<br>    hostnamectl  set-hostname bigdata99</p>
<p>14.解压缩<br>    zip<br>    gz &#x3D;&gt; gzip</p>
<p>zip:<br>    压缩：<br>        zip log.zip 1.log 2.log 3.log<br>    解压：<br>        unzip<br>        unzip  file[.zip]  [-d exdir]<br>            eg:<br>                unzip .&#x2F;log.zip<br>                unzip .&#x2F;log.zip -d .&#x2F;dir1<br>gzip:<br>    文件<br>    归档文件 tar</p>
<p>文件：1.log 2.log 3.log<br>归档文件: test.tar<br>    tar :<br>        归档：<br>            tar -cf test.tar 1.log 2.log 3.log<br>        解归档：<br>            test.tar<br>            tar -xf test.tar -C .&#x2F;dir2</p>
<p>归档文件 做一个压缩：gzip<br>    test.tar &#x3D;》 test.tar.gz<br>        压缩：<br>            tar -zcvf test2.tar.gz 1.log 2.log 3.log<br>        解压：<br>            tar -zxvf .&#x2F;test.tar.gz -C .&#x2F;dir3</p>
<p>15.yum<br>    yum search xxx<br>    yum install -y xxx</p>
<pre><code>httpd

centos 6:
    service httpd start|status|restart|stop

centos 7:
    service httpd start|status|restart|stop  兼容
    systemctl start|status|restart|stop  name...

启动： 
    systemctl start httpd  
进程： 
    ps -ef |  grep httpd

杀死进程： 
    kill -9 pid
    kill -9 $(pgrep -f httpd)
    补充： 
浏览器： http://ip:80
        https://ip:443

查端口： 
    netstat -nlp | grep httpd

:::80 =&gt; ip:80 web   
ip:80
0.0.0.0:80 
    外部机器可以访问 
    
    外部机器不可以访问
127.0.0.1:80  自己可以访问
localhost:80

curl localhost:80

补充： 
  kill -9 $(pgrep -f httpd)
</code></pre>
<p>app &#x3D;》pid<br>    思考：每个进程都会有 对外提供服务的端口么？<br>        不一定 </p>
<pre><code>场景： 
    大数据平台 webui 老板 找一下webui? port 忘记了 ？ 

    启动=》 进程名字 =》 ps -ef | grep name =&gt;pid 
    netstat -nlp | grep pid =&gt; port 
    ip:port
    
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell</title>
    <url>/2024/10/04/Shell/</url>
    <content><![CDATA[<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><span id="more"></span>
<h2 id="1-什么是shell"><a href="#1-什么是shell" class="headerlink" title="1.什么是shell?"></a>1.什么是shell?</h2><pre><code>1.普通的文件
2.linux命令组成
3.编程语言
</code></pre>
<h1 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h1><h2 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h2><pre><code>1.文件命名 结尾 一般都是以 .sh 结尾
2.文件内容 第一行 #!/bin/bash 

1.编写脚本 
    wordcount  词频统计
    helloworld 

[root@bigdata99 shell]# cat wc.sh 
#!/bin/bash
echo &quot;www.bigdata.com&quot;

2.运行shell脚本
    1.sh xxx.sh
        [root@bigdata99 shell]# sh ./wc.sh 
        www.bigdata.com
    2.给脚本赋予 执行权限 
        chmod 744 ./wc.sh
        [root@bigdata99 shell]# ./wc.sh 
        www.bigdata.com
        [root@bigdata99 shell]# /root/shell/wc.sh
        www.bigdata.com

3.补充： 
    debug 
        1.[root@bigdata99 shell]# cat wc.sh 
            #!/bin/bash -x
            echo &quot;www.bigdata.com&quot;
        2.[root@bigdata99 shell]# sh -x wc.sh 
        + echo www.bigdata.com
        www.bigdata.com
</code></pre>
<h2 id="2-定义变量-与-引用"><a href="#2-定义变量-与-引用" class="headerlink" title="2.定义变量 与 引用"></a>2.定义变量 与 引用</h2><pre><code>1.变量的命名规范： 
    1.命名只能使用英文字母、数字、和下划线、不能以数字开头
    2.中间不能有空格、可以使用下划线
    3.不能使用linux里面的关键字

2.定义变量
    key=value
    注意： 
        1.=前后不能有空格

    1.静态： 
        k=v  k=&quot;v&quot; k=&#39;v&#39;
    2.动态
        k=`v`
引用： 
    $k 
    $&#123;k&#125;

    场景： 
        zs  
            zszhenshuai
</code></pre>
<h2 id="3-传递参数"><a href="#3-传递参数" class="headerlink" title="3.传递参数"></a>3.传递参数</h2><pre><code>脚本内获取脚本外的参数  脚本内定一个参数： 格式 $n
    1.n表示数字
    2.n=1 作为脚本的第一个参数 n=2作为脚本的第2个参数...
    3.n=0 获取脚本的名字
[root@bigdata99 shell]# ./parameter.sh &quot;hello&quot; &quot;zs&quot;
hello
zs
[root@bigdata99 shell]# cat parameter.sh 
echo &quot;文件名：$0&quot;
echo &quot;第一个参数：$1&quot;
echo &quot;第二个参数：$2&quot;
echo &quot;参数的个数：$#&quot;
echo &quot;传递的参数作为一个字符串：$*&quot;  
echo &quot;此脚本运行时的pid：$$&quot;

补充： 
    ps -ef | grep xxx  =&gt; pid 
    kill -9 pid 
</code></pre>
<h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h2><pre><code>语法格式： 
    1.元素 是 空格 进行分割 
    2.arr=(value1 value2 value3 ...)
[root@bigdata99 shell]# cat arr.sh 
arr=(zs lisi ww zl wrm)
echo &quot;所有数组元素：$&#123;arr[*]&#125;&quot; 
echo &quot;第2个元素：$&#123;arr[1]&#125;&quot;
echo &quot;数组元素个数：$&#123;#arr[*]&#125;&quot;
</code></pre>
<h2 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5.流程控制"></a>5.流程控制</h2><pre><code>分支、循环 

1.if else 语法
    语法结构： 
    if condition;then
        command
    else 
        command
    fi

2.condition 条件判断 
    [ 表达式 ]
    1.值判断
        true false

        = 等于
        ==等于
        &lt;= &gt;= &gt; &lt; !=
        -eq 等于
        -ne 不等于
        -lt 小于
        -gt 大于 
        -le 小于等于
        -ge 大于等于

补充： 
    1.[] 前后要有空格 
    2.关系表达式 前后要有空格 
linux 获取上一个命令是否执行成功： 
    $? 
        成功 0  true
        不成功 非0 false

    2.权限判断:
        -r 
        -w 
        -x
    3.文件类型判断
        -d 
        -f 
        -e 
</code></pre>
<p>[root@bigdata99 shell]# cat if.sh<br>a&#x3D;”zs”<br>b&#x3D;”zs”<br>if [ ${a} &#x3D;&#x3D; ${b} ];then<br>    echo “&#x3D;&#x3D;”<br>else<br>    echo “!&#x3D;”<br>fi</p>
<pre><code>2.if elseif 语法
语法结构： 
    if condition;then
        command
    elif condition;then
        command
    else 
        command
    fi

    补充： &amp;&amp; ||
</code></pre>
<p>[root@bigdata99 shell]# cat ifelse.sh </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#统计期末成绩 优良差  </span><br><span class="line">#&gt;=<span class="number">90</span> 优  &gt;=<span class="number">60</span> 良  &lt;<span class="number">60</span> 差</span><br><span class="line"></span><br><span class="line">score=$<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> [ $&#123;score&#125; -ge <span class="number">90</span> ];then</span><br><span class="line">	echo <span class="string">&quot;优&quot;</span></span><br><span class="line">elif [ $&#123;score&#125; -ge <span class="number">60</span> ];then</span><br><span class="line">	echo <span class="string">&quot;良&quot;</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	echo <span class="string">&quot;差&quot;</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">	循环： </span><br><span class="line">		<span class="keyword">for</span>、<span class="keyword">while</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>: </span><br><span class="line">		语法结构 </span><br><span class="line">		<span class="keyword">for</span> x in item1 item2 item3 ... itemN</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">			command1</span><br><span class="line">			...</span><br><span class="line">		done</span><br><span class="line">	[root<span class="meta">@bigdata99</span> shell]# cat <span class="keyword">for</span>.sh </span><br><span class="line">	<span class="keyword">for</span> x in <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">		echo $&#123;x&#125;</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>
<pre><code>2. fori 
    打印 10以内的数字
    [root@bigdata99 shell]# cat fori.sh 
    for((i=0;i&lt;10;i++))
    do
        echo &quot;value is $&#123;i&#125;&quot;
    done

3.while
    语法结构： 
        while condition
        do 
            todo....
        done
    案例： 
        打印 10以内的数字
    
    [root@bigdata99 shell]# cat while.sh 
# 打印 10以内的数字

i=1
while ((i&lt;=10))
do
    echo $&#123;i&#125;
    let i++
done
</code></pre>
<p>场景：<br>    有一个字符串”zhangsan,lisi,zhaoliu”</p>
<pre><code>如何分割字符串？ 
    java  split（&quot;,&quot;） =》 array =》for
    linux  把, =》 空格    =》 array


    1.字符串替换： 
        str//,/ 
            =&gt;zhangsan,lisi,zhaoliu
            =&gt;zhangsan lisi zhaoliu
    [root@bigdata99 shell]# cat split.sh 
        str=&quot;zhangsan,lisi,zhaoliu&quot;
        arr=($&#123;str//,/ &#125;)
        for var in $&#123;arr[*]&#125;
        do
            echo $var
        done
    2.IFS变量进行字符串分割【了解】
</code></pre>
<h2 id="6-shell里面常用的分析工具"><a href="#6-shell里面常用的分析工具" class="headerlink" title="6.shell里面常用的分析工具"></a>6.shell里面常用的分析工具</h2><h2 id="1-awk-文本分析"><a href="#1-awk-文本分析" class="headerlink" title="1.awk 文本分析"></a>1.awk 文本分析</h2><h3 id="1-获取列数据"><a href="#1-获取列数据" class="headerlink" title="1.获取列数据"></a>1.获取列数据</h3><pre><code>        [root@bigdata99 ~]# cat test.log 
        a b c
        1 2 3
        [root@bigdata99 ~]# cat test.log | awk &#39;&#123;print $1&#125;&#39;
        a
        1
        [root@bigdata99 ~]# cat test.log | awk &#39;&#123;print $2&#125;&#39;
        b
        2
        [root@bigdata99 ~]# cat test.log | awk &#39;&#123;print $1,$2&#125;&#39;
        a b
        1 2
</code></pre>
<h3 id="2-获取行数据"><a href="#2-获取行数据" class="headerlink" title="2.获取行数据"></a>2.获取行数据</h3><pre><code>        [root@bigdata99 ~]# cat test.log | awk &#39;NR==1&#123;print&#125;&#39;
</code></pre>
<h2 id="2-sed"><a href="#2-sed" class="headerlink" title="2.sed"></a>2.sed</h2><pre><code>    文本替换
</code></pre>
<h3 id="1-文本中a-替换成d-每行第一次遇到a-替换成d-【不常用】"><a href="#1-文本中a-替换成d-每行第一次遇到a-替换成d-【不常用】" class="headerlink" title="1.文本中a 替换成d 每行第一次遇到a 替换成d  【不常用】"></a>1.文本中a 替换成d 每行第一次遇到a 替换成d  【不常用】</h3><pre><code>        sed -i  &#39;s/a/d/&#39;    test.log
</code></pre>
<h3 id="2-全文替换"><a href="#2-全文替换" class="headerlink" title="2.全文替换"></a>2.全文替换</h3><pre><code>        sed -i &#39;s/a/d/g&#39; test.log
    
    补充： 
        [root@bigdata99 ~]# cat path.log 
        p1=/data/log
        p2=/data/spark

    需求： 
        p2 值路径 替换成 /root 

        sed -i &#39;s//data/spark//root/g&#39;  path.log  错误的
        转义： \
        sed -i &#39;s/\/data\/spark/\/root/g&#39;  path.log

        [root@bigdata99 ~]# cat path.log 
        p1=/data/log
        p2=/root

        sed -i &#39;s#/root#/data/spark#g&#39; path.log
</code></pre>
<h1 id="1-机器克隆"><a href="#1-机器克隆" class="headerlink" title="1.机器克隆"></a>1.机器克隆</h1><h2 id="1-准备模板机"><a href="#1-准备模板机" class="headerlink" title="1.准备模板机"></a>1.准备模板机</h2><h2 id="2-网络配置-ip-静态ip"><a href="#2-网络配置-ip-静态ip" class="headerlink" title="2.网络配置  &#x3D;&gt; ip 静态ip"></a>2.网络配置  &#x3D;&gt; ip 静态ip</h2><pre><code>    网卡： 
        vim /etc/sysconfig/network-scripts/ifcfg-ens33
            BOOTPROTO=&quot;static&quot; 
            ONBOOT=&quot;yes&quot;
            IPADDR=192.168.41.11
            GATEWAY=192.168.41.2
            DNS1=192.168.41.2
</code></pre>
<h2 id="3-机器自带没用的东西-去除掉"><a href="#3-机器自带没用的东西-去除掉" class="headerlink" title="3.机器自带没用的东西 去除掉"></a>3.机器自带没用的东西 去除掉</h2><pre><code>        1.jdk卸载掉：
            rpm -qa | grep java
                xxx 
                xx
                x
            卸载： 
            rpm -e xxx --nodeps
            rpm -e xx --nodeps
            rpm -e x --nodeps
        2.hostname
            vim /etc/hostname
            bigdata11
        3.内网ip 与hostname 映射
            vim /etc/hosts

            192.168.41.11 bigdata11
            192.168.41.12 bigdata12
            192.168.41.13 bigdata13
            192.168.41.14 bigdata14
            192.168.41.15 bigdata15
            192.168.41.16 bigdata16
</code></pre>
<h2 id="4-防火墙关闭：打开所有端口"><a href="#4-防火墙关闭：打开所有端口" class="headerlink" title="4.防火墙关闭：打开所有端口"></a>4.防火墙关闭：打开所有端口</h2><pre><code>            systemctl status firewalld
            systemctl stop firewalld
            systemctl disable firewalld
</code></pre>
<h1 id="2-vmware-虚拟网络"><a href="#2-vmware-虚拟网络" class="headerlink" title="2.vmware 虚拟网络"></a>2.vmware 虚拟网络</h1><h2 id="1-关闭虚拟机"><a href="#1-关闭虚拟机" class="headerlink" title="1.关闭虚拟机"></a>1.关闭虚拟机</h2><h2 id="2-虚拟网络："><a href="#2-虚拟网络：" class="headerlink" title="2.虚拟网络："></a>2.虚拟网络：</h2><pre><code>        编辑=》虚拟网络=》vm8=》
            子网ip：192.168.41.0
            子网掩码：255.255.255.0
            nat设置：192.168.41.2
</code></pre>
<h2 id="3-开机："><a href="#3-开机：" class="headerlink" title="3.开机："></a>3.开机：</h2><pre><code>        验证内网ip ： ifconfig
            192.168.41.11 bigdata11
</code></pre>
<h2 id="4-远程登录"><a href="#4-远程登录" class="headerlink" title="4.远程登录"></a>4.远程登录</h2><pre><code>        xshell ： 
            ip 
            用户名
            密码
            port
</code></pre>
<h1 id="2-克隆机器"><a href="#2-克隆机器" class="headerlink" title="2.克隆机器"></a>2.克隆机器</h1><pre><code>    注意： 
        创建完整克隆
</code></pre>
<h2 id="1-修改克隆机器的内网ip"><a href="#1-修改克隆机器的内网ip" class="headerlink" title="1.修改克隆机器的内网ip"></a>1.修改克隆机器的内网ip</h2><pre><code>        vim /etc/sysconfig/network-scripts/ifcfg-ens33
</code></pre>
<h2 id="2-hostname"><a href="#2-hostname" class="headerlink" title="2.hostname"></a>2.hostname</h2><pre><code>        vim /etc/hostname
</code></pre>
<h2 id="3-重启机器"><a href="#3-重启机器" class="headerlink" title="3.重启机器"></a>3.重启机器</h2>]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>git3</title>
    <url>/2024/10/06/git3/</url>
    <content><![CDATA[<h1 id="git3"><a href="#git3" class="headerlink" title="git3"></a>git3</h1><span id="more"></span>
<h1 id="如何修改commit的msg-信息"><a href="#如何修改commit的msg-信息" class="headerlink" title="如何修改commit的msg 信息"></a>如何修改commit的msg 信息</h1><pre><code>1.修改最新的commit的msg
    git commit --amend

2.修改之前某一个的commit的msg
    git rebase   -- 变基
    git rebase -i &lt;after-this-commit&gt; ： 
            -i 表示交互式
    修改之前某一个的commit = 基于前一个commit 进行修改当前的commit 
</code></pre>
<p>p, pick <commit> &#x3D; use commit  &#x3D;》 选择某个commit<br>r, reword <commit> &#x3D; use commit, but edit the commit message 重写某个commit msg<br>s, squash <commit> &#x3D; use commit, but meld into previous commit 合并多个commit msg</p>
<pre><code>3.合并多个commit的msg 合并成一个commit msg
    git rebase -i &lt;after-this-commit&gt; 
</code></pre>
<h1 id="工作区-vs-暂存区-vs-本地仓库"><a href="#工作区-vs-暂存区-vs-本地仓库" class="headerlink" title="工作区 vs 暂存区 vs 本地仓库"></a>工作区 vs 暂存区 vs 本地仓库</h1><pre><code>1.查看文件差异 
git status  =&gt; 文件的个数 名字

2.查看文件内容差异 
    所有文件内容差异：
        1.比较 不同工作区 
 git diff 	工作区 vs 暂存区 文件内容差异
 git diff --cached  暂存区 vs 本地仓库 文件内容差异
 		2.比较不同的commit 之间差异
         git diff 9cbef63 0aece3e
         git diff HEAD 0aece3e
         git diff HEAD HEAD~1
         git diff HEAD HEAD~2

         git diff HEAD HEAD~2 -- 2.log 1.log

         git diff a分支 b分支

3.恢复操作 
    工作区 vs 暂存区 vs 本地仓库 
    1.工作区 =》 暂存区 
        1.git add 
            可以进行撤回
            git restore --staged &lt;file&gt;...
            git restore --staged 1.log 2.log 3.log
        2.工作区：git add 之前 
            编写代码 也可以撤回
            git restore &lt;file&gt;...
            git restore 3.log

    2.暂存区 vs 本地仓库 可以撤回
        git commit 之前： 
        git reset --hard HEAD  =&gt;回退版本
</code></pre>
<h1 id="删除文件-文件重命名"><a href="#删除文件-文件重命名" class="headerlink" title="删除文件 文件重命名"></a>删除文件 文件重命名</h1><pre><code>git ： 建议 
    相关命令 进行操作
1.删除/重命名文件 
    git rm/mv 
     git commit -m &quot;Rm 11.log&quot;

2.补充： 【了解】
    rm: git rm 
        rm -rf xxx 
        git add xxx 
        git commit -m &quot;Rm xxx&quot;

    mv : git mv 
</code></pre>
<h1 id="紧急任务"><a href="#紧急任务" class="headerlink" title="紧急任务"></a>紧急任务</h1><p> 开发代码 &#x3D;》 线上bug &#x3D;》commit<br>            &#x3D;》开发代码 存起来 &#x3D;》恢复出来 进行开发</p>
<pre><code>git stash 

1.开发代码
$ vim 2.log

2.突然线上bug +解决bug
git stash
commit 

3.恢复 解决bug之前的开发代码
git stash list
git stash apply  补充 ： --index &lt;stash 下标&gt;
</code></pre>
<h1 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h1><pre><code>通过这个文件 可以指定 哪些文件 不需要被git管控
-- java 
    =》 xxx.java  =&gt; xxx.class
    =&gt; .idea 文件里面的文件 也是不需要被管控

eg： 
    *.class  =》以.class文件结尾的 不需要被 git管控 
    log/
    
</code></pre>
<h1 id="仓库备份：克隆"><a href="#仓库备份：克隆" class="headerlink" title="仓库备份：克隆"></a>仓库备份：克隆</h1><pre><code>git clone： 
    git clone  &lt;repository&gt; [&lt;directory&gt;]

    repository： 仓库
        本地仓库： path
        远程仓库：url 

1.本地仓库 备份到 本地 【不会用的】
git clone /e/test/music/.git music_blk


2.远程仓库 备份到 本地 【常用的】
    远程仓库： 
        本地项目
        代码托管平台：github、gitlab、gitee

    git clone http://192.168.41.110/dl2262/dl2262.git
</code></pre>
<h1 id="本地仓库-与-远程仓库-交互"><a href="#本地仓库-与-远程仓库-交互" class="headerlink" title="本地仓库 与 远程仓库 交互"></a>本地仓库 与 远程仓库 交互</h1><pre><code>1.本地仓库 连接到 远程仓库
git remote: 
    git remote add &lt;name&gt; &lt;URL&gt;

    1.连接远程仓库： 
    git remote add gitlab http://192.168.41.110/dl2262/test01.git
    2.检查远程仓库的连接 
        git remote -v
    
    3.本地仓库 push 远程仓库 
        git push  ==&gt; 更新远程仓库的分支

        git push [--all ] =&gt; 本地所有分支 更新到远程仓库 分支
        git push [&lt;repository&gt; [&lt;refspec&gt;…​]]
                    =》更新 可以选择 哪个远程仓库 哪个分支


        eg： 
            git push --all 
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push --all</span><br><span class="line"></span><br><span class="line"> * [new branch]      dev -&gt; dev   =》 本地dev =》 远程 自动给远程 dev 分支</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first) </span><br><span class="line">error: failed to push some refs to &#x27;http://192.168.41.110/dl2262/test01.git&#x27;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure>
<p>解决：<br>    先拉下来：<br>        git fetch &#x2F; git pull :<br>            git fetch  [<repository> [<refspec>…​]] &#x3D;》可以指定拉取哪个仓库哪个分支<br>            git fetch –all  &#x3D;&gt; 拉取远程仓库 所有分支</p>
<pre><code>    git fetch gitlab master  =&gt;默认先把远程 分支拉下来 但是文件没有和 本地分支 进行合并 
    git merge 远程分支： 
        ：
    git merge gitlab/master
        fatal: refusing to merge unrelated histories

    git merge --allow-unrelated-histories gitlab/master    
    git push gitlab master
</code></pre>
<p>场景：<br>    1.多人协同开发 常用操作</p>
<pre><code>    1.多人共同维护同一个分支 操作不同的文件 【不会有代码冲突问题】
        1.远程仓库创建一个分支 
            bigdata 
        2.准备两个 本地仓库 
        git clone http://192.168.41.110/dl2262/test01.git test01_blk

        3.zhangsan 开发项目 提交到 远程仓库 
        4.lisi开发项目 提交到 远程仓库
            1.git fetch 
            2.git merge 
            3.git push 

        注意： 
            1.拉取远程仓库代码 =》 本地仓库 和 远程仓库保持一致

            git pull  &lt;=&gt; git fetch  + git merge

    1.注意： 只有一种场景会有冲突：

        1.多人共同维护同一个分支 操作相同的文件 不同位置 =》 不会有冲突

            1.zhangsan 
                vim README.md
                 git add ./README.md
                 git commit -m &quot;Update Readme zhangsan&quot;
                 git branch -av
                  git remote -v
                   git push gitlab bigdata

            2.lisi 
                vim README.md
                 git commit -am &quot;Update Readme lisi&quot;
                 git branch -av
                git remote -v
                 git push origin bigdata
                To http://192.168.41.110/dl2262/test01.git
                ! [rejected]        bigdata -&gt; bigdata (fetch first)

                git fetch origin bigdata =&gt;更新本地仓库 
                 git merge origin/bigdata 
                     Auto-merging README.md
                    CONFLICT (content): Merge conflict in README.md

                    git add README.md
                    git commit -m &quot;Resolved conflict by hand&quot;
                    git branch -av
                    git remote -v
                    git push origin  bigdata

        多人共同维护同一个分支 操作相同的文件 的内容相同位置 
            git pull 

    
    2.如何切换远程仓库  版本
        1.本地切换 
            git log  --oneline
            git reset --hard fd1e890
            git branch -av
        2.强制push 
            git push -f gitlab bigdata

            远程仓库有要求：
                保护分支的机制
</code></pre>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git2</title>
    <url>/2024/10/06/git2/</url>
    <content><![CDATA[<h1 id="git2"><a href="#git2" class="headerlink" title="git2"></a>git2</h1><span id="more"></span>
<p>练习：<br>    编写一个小项目 ，提交到git本地仓库 </p>
<pre><code>工作区： 开发代码 
        =》 git add xxx
暂存区 ： 暂时存放我们开发的代码文件 
        =》 git commit 
本地仓库:存放各个版本的历史

-- 前端项目 github 下载 html 项目
</code></pre>
<h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>git init music</p>
<p>2.– 添加一个index.html文件<br>git add index.html<br>git commit -m “Add index.html”<br>git log</p>
<h1 id="编写其他文件"><a href="#编写其他文件" class="headerlink" title="编写其他文件"></a>编写其他文件</h1><p>git status<br>git add font&#x2F;  icon&#x2F; image&#x2F; music&#x2F;<br>git status<br>git commit -m “Add other data”<br>git status<br>git log</p>
<h1 id="添加页面样式"><a href="#添加页面样式" class="headerlink" title="添加页面样式"></a>添加页面样式</h1><p>git status<br>git add  script.js  style.css<br>git status<br>git commit -m “Add css&amp;js”<br>git status<br>git log</p>
<h1 id="修改代码文件"><a href="#修改代码文件" class="headerlink" title="修改代码文件"></a>修改代码文件</h1><p>git status<br>修改了代码文件 新增文件<br>git status<br>git add -u<br>git status<br>git commit -m “Update”<br>git status<br>git log</p>
<p>补充：<br>    1.git add -u </p>
<pre><code>2.git log =&gt; 查看版本历史： 
</code></pre>
<p>git log  ：<br>    –reflog  &#x3D;》 查看所有操作的 commit 历史</p>
<h1 id="指定输出格式"><a href="#指定输出格式" class="headerlink" title="指定输出格式"></a>指定输出格式</h1><pre><code>format
git log --format=oneline 
git log --oneline [常用]

git log  --oneline --reflog 可以连用 
git log --oneline -n 2  显示最近几个commit

-n 2： 
    使用场景： 
        1.commit 特别多的时候 
        2.分支有关
</code></pre>
<h1 id="分支："><a href="#分支：" class="headerlink" title="分支："></a>分支：</h1><pre><code>一个分支一条线 
默认分支： 
    主分支：主线 master
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	git branch:</span><br><span class="line">		branch    List, create, or delete branches</span><br><span class="line">	</span><br><span class="line">	git branch [--color[=&lt;when&gt;] | --no-color] [--show-current]</span><br><span class="line">        [-v [--abbrev=&lt;n&gt; | --no-abbrev]]</span><br><span class="line">        [--column[=&lt;options&gt;] | --no-column] [--sort=&lt;key&gt;]</span><br><span class="line">        [--merged [&lt;commit&gt;]] [--no-merged [&lt;commit&gt;]]</span><br><span class="line">        [--contains [&lt;commit&gt;]] [--no-contains [&lt;commit&gt;]]</span><br><span class="line">        [--points-at &lt;object&gt;] [--format=&lt;format&gt;]</span><br><span class="line">        [(-r | --remotes) | (-a | --all)]</span><br><span class="line">        [--list] [&lt;pattern&gt;…​]</span><br><span class="line">git branch [--track[=(direct|inherit)] | --no-track] [-f]</span><br><span class="line">        [--recurse-submodules] &lt;branchname&gt; [&lt;start-point&gt;]</span><br><span class="line">git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]</span><br><span class="line">git branch --unset-upstream [&lt;branchname&gt;]</span><br><span class="line">git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt;</span><br><span class="line">git branch (-c | -C) [&lt;oldbranch&gt;] &lt;newbranch&gt;</span><br><span class="line">git branch (-d | -D) [-r] &lt;branchname&gt;…​</span><br><span class="line">git branch --edit-description [&lt;branchname&gt;]</span><br></pre></td></tr></table></figure>
<pre><code>1.创建分支 
  git branch -c dev  =&gt;默认从master直接复制来的
2.查看分支 
    git branch -v
3.切换分支
    git checkout dev 
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline  master  =&gt; 指定查看某个分支的 commit 历史 </span><br><span class="line">git log --oneline --gragh  =&gt; 以图形化界面展示 分支的commit 历史</span><br><span class="line">git log --oneline --gragh --all =&gt; 以图形化界面展示 所有分支 的commit 历史</span><br><span class="line">gitk --all ：</span><br></pre></td></tr></table></figure>
<pre><code>1.历史树  分支线 
2.path =》 记录当前commit 变更文件 
3.tree =》 记录当前commit 下文件结构 
</code></pre>
<p>补充： 创建分支同时并切换分支<br>分支： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout</span><br><span class="line"></span><br><span class="line">git checkout [-b|-B|--orphan] &lt;new-branch&gt;] [&lt;start-point&gt;]</span><br><span class="line">eg: </span><br><span class="line">	创建分支同时并切换分支</span><br><span class="line">git checkout -b bigdata 61b6bb8</span><br><span class="line">git branch -v</span><br><span class="line">gitk --all</span><br><span class="line">vim 1.log</span><br><span class="line"> git add 1.log</span><br><span class="line"> git status</span><br><span class="line">  git commit -m &quot;Add 1.log&quot;</span><br><span class="line">   git log --oneline --graph --all</span><br><span class="line">gitk --all</span><br></pre></td></tr></table></figure>


<pre><code>从工作区 =》 本地仓库 ：
     git branch -c java
     git checkout java
     gitk --all
      vim 1.log
      git add -u
       git commit -m &quot;Update 1.log&quot;
       git log --oneline
       vim 1.log
        git status
        git commit -am &quot;Updata 1.log add 3333&quot;  !!!! 

注意：
    git commit -am 
        -a 表示 工作区 暂存区 文件都有的前提下 ，更改工作区文件 可以直接提交到本地仓库 
            但是 新增文件 不可以
</code></pre>
<h1 id="S删除分支"><a href="#S删除分支" class="headerlink" title="S删除分支"></a>S删除分支</h1><pre><code>git branch (-d | -D)  &lt;branchname&gt;…
    -d： 删除分支之前 要求merge 到主分支 
    -D: 强制删除分支 
</code></pre>
<p>merge： 合并分支<br>    git branch -d java<br>error: The branch ‘java’ is not fully merged.<br>If you are sure you want to delete it, run ‘git branch -D java’</p>
<pre><code> git branch -D java
 git branch -v
</code></pre>
<p>.git文件夹 目录介绍:<br>    1.HEAD 文件 当前项目 正在工作的分支是谁<br>        cat HEAD<br>        ref: refs&#x2F;heads&#x2F;master</p>
<pre><code>2.config ： 
    记录项目的一些参数 一些配置信息 

git config --local user.name &quot;zihang&quot;  =》 set 设置参数 
git config --local user.name           =》 get操作

3.refs/ 
    heads/  存储的是分支的指向 哪个commit

        commit hash =》 对应存储的文件内容是什么？
    
        git cat-file 
                    -t  =》 文件类型 =》 git存储文件 有关系 
                    -p  =&gt; 文件内容

    object：是git存储的真正对象 种类有 如下
        commit：
            tree  =》 
                tree =》文件夹
                blob =》 文件
            
        git存储文件高效的原因：
            不同的文件 只要文件内容有相同的部分 就是一个 blob 
        
</code></pre>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>gittest</tag>
      </tags>
  </entry>
  <entry>
    <title>java api</title>
    <url>/2024/10/02/java-api/</url>
    <content><![CDATA[<h1 id="java-api"><a href="#java-api" class="headerlink" title="java api"></a>java api</h1><span id="more"></span>
<h1 id="参数设置的优先级："><a href="#参数设置的优先级：" class="headerlink" title="参数设置的优先级："></a>参数设置的优先级：</h1><pre><code>1.默认配置文件
    core-default.xml
    hdfs-default.xml
    mapred-default.xml
    yarn-default.xml
2.生产配置文件
    core-site.xml
    hdfs-site.xml
    mapred-site.xml
    yarn-site.xml
3.代码里面设置的参数
     Configuration

优先级排序：代码里面设置的参数 》 生产配置文件 》 默认配置文件
</code></pre>
<h1 id="1-使用java-api-操作-hdfs在-创建文件夹"><a href="#1-使用java-api-操作-hdfs在-创建文件夹" class="headerlink" title="1.使用java api 操作 hdfs在 创建文件夹"></a>1.使用java api 操作 hdfs在 创建文件夹</h1><pre><code> /data/dt=20221114
 /data/dt=20221115
 /data/dt=20221116
</code></pre>
<h1 id="2-使用java-api-上传本地-wc-data-到上面三个目录下"><a href="#2-使用java-api-上传本地-wc-data-到上面三个目录下" class="headerlink" title="2.使用java api 上传本地 wc.data 到上面三个目录下"></a>2.使用java api 上传本地 wc.data 到上面三个目录下</h1><h1 id="3-使用java-api-将"><a href="#3-使用java-api-将" class="headerlink" title="3.使用java api 将"></a>3.使用java api 将</h1><pre><code>/data/dt=20221114/wc.data
/data/dt=20221115/wc.data
/data/dt=20221116/wc.data
目录下的文件移动到 指定目录 并进行改名字
/data/hive/20221114-01.data
/data/hive/20221115-01.data
/data/hive/20221116-01.data
</code></pre>
<h1 id="创建文件夹-上传-改名字"><a href="#创建文件夹-上传-改名字" class="headerlink" title="创建文件夹  上传 改名字"></a>创建文件夹  上传 改名字</h1><p> path:<br>    hdfspath  上传的path<br>    localpath  本地path<br>    filename   文件名字<br>    renamepath  修改文件的路径的path<br>    renamesufname 修改后文件的结尾<br>    dt         </p>
<p>hadoop jar &#x2F;home&#x2F;hadoop&#x2F;project&#x2F;DL2262-hdfsapi-1.0.jar <br>com.bigdata.HomeWork01 <br>“&#x2F;data&#x2F;dt&#x3D;” “file:&#x2F;&#x2F;&#x2F;&#x2F;home&#x2F;hadoop” “1.log” “&#x2F;data&#x2F;flink” “-01.data” “20221117”</p>
<p>start.sh<br>if [ $# -lt 6 ];then<br>    echo “Usage:put file to hdfs”<br>    echo “Usage:$0 <hdfspath> <localpath> <filename> <renamepath> <suffname> <dt>“<br>    echo “Usage:<hdfspath> is hdfs path”<br>    echo “eg:$0 ‘&#x2F;data&#x2F;dt&#x3D;’ ‘file:&#x2F;&#x2F;&#x2F;&#x2F;home&#x2F;hadoop’ ‘1.log’ ‘&#x2F;data&#x2F;flink’ ‘-01.data’ ‘20221117’”<br>    exit;<br>fi</p>
<p>hadoop jar &#x2F;home&#x2F;hadoop&#x2F;project&#x2F;DL2262-hdfsapi-1.0.jar <br>com.bigdata.HomeWork01 <br>“${1}” “${2}” “${3}” “${4}” “${5}” “${6}”</p>
<h1 id="HDFS：负责存储数据"><a href="#HDFS：负责存储数据" class="headerlink" title="HDFS：负责存储数据"></a>HDFS：负责存储数据</h1><pre><code>1.文件进行拆分 文件块
2.存储 拆分 文件块
</code></pre>
<h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><pre><code>hdfs主要存储文件 大文件  不是说 不能存储小文件
存储小文件 影响hdfs 性能
</code></pre>
<h1 id="block-块-："><a href="#block-块-：" class="headerlink" title="block 块 ："></a>block 块 ：</h1><pre><code>1.怎么来的？
    文件拆分来的 【按照 块大小 进行拆分】
2.属性：
    1.块大小 128M blocksize
    2.块的副本数:
        1.伪分布式 1
        2.完全分布式 3
            1.3  3
            2.&gt;3 3

本地文件大小：260M
块大小 ：128m

      块实际存储      规格【块大小】 128M
</code></pre>
<p> 第一块	   128M				128M<br> 第二块	   128M				128M<br> 第三块		4M				128M</p>
<h1 id="S假如："><a href="#S假如：" class="headerlink" title="S假如："></a>S假如：</h1><pre><code>一缸水 260L
一个瓶子 128l
</code></pre>
<p>第一个瓶子  128l   128L<br>第二个瓶子  128l<br>第三个瓶子  4L</p>
<p>160M 2个副本 问：<br>    1.文件拆分了块在hdfs上存了多少个块？<br>160M：<br>128M  &#x3D;&gt; 1<br>32M   &#x3D;&gt; 1<br>1+1 &#x3D;2 块  * 2 &#x3D; 4个块</p>
<pre><code>2.实际存储到hdfs 存储的大小是多少？
    160m * 2 = 320M
</code></pre>
<p>[hadoop@bigdata32 subdir0]$ pwd<br>&#x2F;home&#x2F;hadoop&#x2F;data&#x2F;hadoop&#x2F;dfs&#x2F;data&#x2F;current&#x2F;BP-155707757-192.168.41.32-1668441906801&#x2F;current&#x2F;finalized&#x2F;subdir0&#x2F;subdir0</p>
<p>练习：<br>    hdfs api 完成wordcount 统计</p>
<p>大数据处理：<br>    1.input<br>    2.处理<br>    3.output</p>
<pre><code>hdfs 存储一堆文件 让你统计每个单词出现的次数？
1.input
    hdfs 一些文件
    fs.open
2.处理
    词频统计
    1.读取进来的内容 一行一行的 ，按照某个规则指定分隔符 进行拆分 =》一个一个单词
    2.给每个单词 赋值为1
        a,a,a,b,b
     =&gt;
     	(a,1)
        (a,1)
        (a,1)
        (b,1)
        (b,1)
    3.将相同的单词 存起来 一个集合里面
        进行聚合统计 每个单词出现的次数
        &lt;a,1,1,1&gt;
        &lt;b,1,1&gt;
        =&gt;
        &lt;a,3&gt;
        &lt;b,2&gt;
3.output
    1.打印到控制台
    2.输出到hdfs上
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>java面试题</title>
    <url>/2024/10/09/java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="java面试题"><a href="#java面试题" class="headerlink" title="java面试题"></a>java面试题</h1><span id="more"></span>
<h2 id="我们通常所说的E-Learning，它的全称是什么？"><a href="#我们通常所说的E-Learning，它的全称是什么？" class="headerlink" title="我们通常所说的E-Learning，它的全称是什么？"></a>我们通常所说的E-Learning，它的全称是什么？</h2><p>继承Thread，实现Runnable接口</p>
<h2 id="java中标识符的命名规则是什么？"><a href="#java中标识符的命名规则是什么？" class="headerlink" title="java中标识符的命名规则是什么？"></a>java中标识符的命名规则是什么？</h2><p>由字母，数字，下划线_,美元符号$<br>不能数字开头<br>区分大小写<br>不能是java中关键字和保留字</p>
<h2 id="Java-语言中的数据类型转换有哪两种？"><a href="#Java-语言中的数据类型转换有哪两种？" class="headerlink" title="Java 语言中的数据类型转换有哪两种？"></a>Java 语言中的数据类型转换有哪两种？</h2><p>自动类型转换：编译器自动完成类型转换，不需要在程序中编写代码。<br>强制类型转换：强制编译器进行类型转换，必须在程序中编写代码。</p>
<h2 id="在java-之中-break和continue的区别"><a href="#在java-之中-break和continue的区别" class="headerlink" title="在java 之中 break和continue的区别"></a>在java 之中 break和continue的区别</h2><p>在java之中，break和continue都可以用来跳出当前循环，但是两者的主要区别是：<br>当循环执行到break语句时，就退出整个循环，然后执行循环外的语句。<br>当循环语句执行到continue时，当次循环结束，重新开始下一轮循环。如果已经是最后一轮循环了，那么这是的continue就与break效果一样了</p>
<h2 id="for-while-do-while三种循环有什么特点和区别？"><a href="#for-while-do-while三种循环有什么特点和区别？" class="headerlink" title="for while do-while三种循环有什么特点和区别？"></a>for while do-while三种循环有什么特点和区别？</h2><p>这三种都是循环语句，其中，for和while语句基本上是一样的，也可以互相替换。但从使用经验上来说，for循环通常用在有固定循环次数的循环语句中，而while语句则用在满足某种条件时才循环的语句中，它们都是先判断条件是否满足再执行语句，所以，如果一开始条件就不满足，循环语句有可能一次也不执行。do-while语句和while基本相同，所不同的是，它先执行循环语句，再判断条件是否满足，也就是说，循环语句至少能执行一次。</p>
<h2 id="类和对象的关系？"><a href="#类和对象的关系？" class="headerlink" title="类和对象的关系？"></a>类和对象的关系？</h2><p>类是模板，是具有相同属性和行为的对象的集合，对象是类的实例</p>
<h2 id="StringBuffered、StringBuilder和String的区别。"><a href="#StringBuffered、StringBuilder和String的区别。" class="headerlink" title="StringBuffered、StringBuilder和String的区别。"></a>StringBuffered、StringBuilder和String的区别。</h2><p> String(JDK1.0)：不可变字符序列，底层使用char[]存储<br>​ StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全，底层使用char[]存储<br>​ StringBuilder(JDK 5.0)：&#x3D;&#x3D;可变字符序列、效率高、线程不安全&#x3D;&#x3D;，底层使用char[]存储</p>
<h2 id="请列举5个常见的异常，并写出其中文意思"><a href="#请列举5个常见的异常，并写出其中文意思" class="headerlink" title="请列举5个常见的异常，并写出其中文意思"></a>请列举5个常见的异常，并写出其中文意思</h2><p>1、ArithmeticExecption  算术异常类<br>2、NullPointerException 空指针异常类<br>3、ClassCastException  类型强制转换异常<br>4、FileNotFoundException 文件未找到异常<br>5、NumberFormatException 字符串转换为数字异常<br>6、IOException   输入输出异常</p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型只在编译过程有效，成功编译过后的 class 文件中是不包含任何泛型信息的<br>看下面的例子：返回结果为 true，原因在于编译时 Box<String> 和 Box<Integer> 的类型都被擦除了<br>，编译后只有 Box 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;String&gt; b1 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;String&gt;(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">Box&lt;Integer&gt; b2 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">System.out.println(b1.getClass() == b2.getClass());</span><br></pre></td></tr></table></figure>
<h2 id="数组和集合的区别"><a href="#数组和集合的区别" class="headerlink" title="数组和集合的区别"></a>数组和集合的区别</h2><p>数组：长度是不可改变的，可以存放任意类型的数据。<br>集合：大小是可变的，只能存引用类型的数据。</p>
<h2 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h2><p>Collection(接口)，存储的是单一对象。<br>Map(接口)，存储的是 key-value(键值对)形式的数据。</p>
<p>Iterator(迭代器)，主要用于遍历 Colleciton<br>Collecitons(工具类)，Colleciton 集合的工具类<br>Comparator&#x2F;Comparable(比较器)， 用于对象之间的比较排序</p>
<h2 id="error和exception有什么区别？"><a href="#error和exception有什么区别？" class="headerlink" title="error和exception有什么区别？"></a>error和exception有什么区别？</h2><p>Error：通常表示严重的系统级错误，这些错误通常是不可恢复的，程序无法通过常规的异常处理机制来处理。例如，OutOfMemoryError 和 StackOverflowError 都是典型的 Error。这些错误通常会导致程序终止或需要虚拟机进行处理。<br>Exception：表示程序在正常运行过程中遇到的可预料的意外情况，这些情况可能并且应该被捕获和处理。Exception 包括受检查异常（Checked Exception）和非受检查异常（Unchecked Exception）。受检查异常需要在代码中显式地处理，而非受检查异常通常是运行时异常（Runtime Exception），如 NullPointerException 和 ArrayIndexOutOfBoundsException。</p>
<h2 id="和eqals的区别"><a href="#和eqals的区别" class="headerlink" title="&#x3D;&#x3D;和eqals的区别"></a>&#x3D;&#x3D;和eqals的区别</h2><h3 id="1-基本数据类型与引用类型的区别："><a href="#1-基本数据类型与引用类型的区别：" class="headerlink" title="1.基本数据类型与引用类型的区别："></a>1.基本数据类型与引用类型的区别：</h3><p>对于基本数据类型（如 int, double, char 等），&#x3D;&#x3D; 比较的是它们的值是否相等。例如，int a &#x3D; 5; int b &#x3D; 5;，a &#x3D;&#x3D; b 会返回 true，因为它们的值相同。<br>对于引用类型（如 String, Integer 等），&#x3D;&#x3D; 比较的是两个对象的引用是否指向内存中的同一个对象，即比较的是对象的内存地址。例如，String str1 &#x3D; new String(“hello”); String str2 &#x3D; new String(“hello”);，str1 &#x3D;&#x3D; str2 会返回 false，因为它们指向不同的对象。</p>
<h3 id="2-equals-方法："><a href="#2-equals-方法：" class="headerlink" title="2.equals() 方法："></a>2.equals() 方法：</h3><p>equals() 方法默认情况下是比较两个对象的引用是否相同，但许多类（如 String, Integer 等）重写了 equals() 方法，使其比较对象的内容是否相同。例如，String str1 &#x3D; “hello”; String str2 &#x3D; “hello”;，str1.equals(str2) 会返回 true，因为它们的内容相同。<br>equals() 方法不能用于基本数据类型的比较，只能用于引用数据类型的比较。</p>
<h3 id="3-Object-类中的-equals-方法："><a href="#3-Object-类中的-equals-方法：" class="headerlink" title="3.Object 类中的 equals() 方法："></a>3.Object 类中的 equals() 方法：</h3><p>equals() 方法是 Object 类的一个方法，默认实现是比较两个对象的引用是否相同。如果需要比较对象的内容，通常需要重写 equals() 方法。</p>
<h3 id="4-使用场景："><a href="#4-使用场景：" class="headerlink" title="4.使用场景："></a>4.使用场景：</h3><p>当需要比较基本数据类型的值时，使用 &#x3D;&#x3D;。<br>当需要比较对象的内容时，使用 equals() 方法。<br>当需要比较对象的引用时，使用 &#x3D;&#x3D;。</p>
<h2 id="用于比较基本数据类型的值或对象的引用，而-equals-方法用于比较对象的内容。理解这两者的区别对于编写正确的Java代码至关重要。"><a href="#用于比较基本数据类型的值或对象的引用，而-equals-方法用于比较对象的内容。理解这两者的区别对于编写正确的Java代码至关重要。" class="headerlink" title="&#x3D;&#x3D; 用于比较基本数据类型的值或对象的引用，而 equals() 方法用于比较对象的内容。理解这两者的区别对于编写正确的Java代码至关重要。"></a>&#x3D;&#x3D; 用于比较基本数据类型的值或对象的引用，而 equals() 方法用于比较对象的内容。理解这两者的区别对于编写正确的Java代码至关重要。</h2>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/10/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>反射、内省、注解</title>
    <url>/2024/10/12/%E5%8F%8D%E5%B0%84%E3%80%81%E5%86%85%E7%9C%81%E3%80%81%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="反射、内省、注解"><a href="#反射、内省、注解" class="headerlink" title="反射、内省、注解"></a>反射、内省、注解</h1><span id="more"></span>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2024/10/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><span id="more"></span>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程-Process"><a href="#进程-Process" class="headerlink" title="进程(Process)"></a>进程(Process)</h3><p>每个独立执行的程序称为进程<br>在操作系统中进程是进行系统资源分配、调度和管理的最小单位<br>进程在执行过程中拥有独立的内存单元。</p>
<h3 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程(Thread)"></a>线程(Thread)</h3><p>线程是一个程序内部的一条执行路径，进程内部单一的一个顺序控制流。<br>Java 虚拟机允许应用程序并发地运行多个执行路径，称为多线程。<br>进程中不同的线程共享内存单元。<br>操作系统是以进程为单位的，而进程是以线程为单位的，进程中必须有一个主线程 main</p>
<h2 id="线程的创建与启动（三种方式）"><a href="#线程的创建与启动（三种方式）" class="headerlink" title="线程的创建与启动（三种方式）"></a>线程的创建与启动（三种方式）</h2><h3 id="方式-1：继承-Thread"><a href="#方式-1：继承-Thread" class="headerlink" title="方式 1：继承 Thread"></a>方式 1：继承 Thread</h3><p>创建线程类： 继承 Thread 类，重写 run 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scl.java.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写线程的业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是子线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用 start()方法启动线程，会自动触发 run 方法</span><br><span class="line"><span class="type">CustomThread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">th.start();</span><br></pre></td></tr></table></figure>

<h3 id="方式-2：实现-Runnable-接口"><a href="#方式-2：实现-Runnable-接口" class="headerlink" title="方式 2：实现 Runnable 接口"></a>方式 2：实现 Runnable 接口</h3><p>创建 Runnable 接口实现类，重写 run 方法。Ruannable 的本质是线程中执行的任务<br>实现步骤：</p>
<ol>
<li>实现Runnable 接口，重写run()方法。<br>Runnable是线程Thread执行的任务。</li>
<li>创建线程<br>Thread th &#x3D; new Thread(Runnable r);</li>
<li>启动<br>th.start();<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scl.java.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.scl.java.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">CountRunnable</span>());</span><br><span class="line">        th.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="方式-3：实现-Callable-接口"><a href="#方式-3：实现-Callable-接口" class="headerlink" title="方式 3：实现 Callable 接口"></a>方式 3：实现 Callable<T> 接口</h3><p>创建 Callable 接口实现类，重新 call()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scl.java.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scl.java.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建任务FutureTask</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">SumCallable</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        th.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得线程的执行结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程的基本方法"><a href="#线程的基本方法" class="headerlink" title="线程的基本方法"></a>线程的基本方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span> 返回对当前正在执行的线程对象的引用</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> 设置线程名称</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span> 返回该线程的名称</span><br></pre></td></tr></table></figure>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>五种状态，即创建、就绪、运行、阻塞、终止。</p>
<ol>
<li><p>概念：进程和线程</p>
</li>
<li><p>*** 线程的三种创建方式</p>
</li>
<li><p>线程的常用方法</p>
</li>
<li><p>*** 线程的生命周期</p>
</li>
<li><p>*** 线程的调度</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>变量和运算</title>
    <url>/2024/10/08/%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="变量和运算"><a href="#变量和运算" class="headerlink" title="变量和运算"></a>变量和运算</h1><span id="more"></span>
<h1 id="1-变量和常量"><a href="#1-变量和常量" class="headerlink" title="1.   变量和常量"></a>1.   变量和常量</h1><h2 id="1-1-内存和硬盘"><a href="#1-1-内存和硬盘" class="headerlink" title="1.1  内存和硬盘"></a>1.1  内存和硬盘</h2><p>硬盘是以文件的形式永久存储数据的。内存用于临时存放在CPU中的运算数据。</p>
<h2 id="1-2-变量概述"><a href="#1-2-变量概述" class="headerlink" title="1.2  变量概述"></a>1.2  变量概述</h2><p>变量是通过内存来临时保存数据的。</p>
<p>变量的信息包括变量名（数据名）和变量值（数据值）。</p>
<h2 id="1-3-变量的声明和赋值"><a href="#1-3-变量的声明和赋值" class="headerlink" title="1.3  变量的声明和赋值"></a>1.3  变量的声明和赋值</h2><p>声明：给变量起个名字。<br>语法：数据类型 变量名;</p>
<p><strong>命名方式：变量名采用小驼峰式命名，如****“bookName”</strong><br>  赋值：给变量赋予一个值。<br>  语法：变量名 &#x3D; 值;<br>声明和赋值可以一次完成。</p>
<p>多个变量类型相同可以同时声明。<br>当类型相同且同类作用的变量可以一起声明和赋值<br>变量初始化之后，可以重新赋值。</p>
<h2 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h2><p>固定的值或者不能改变值的变量，称为常量。<br>固定值，如10。<br><strong>final</strong> 修饰的变量<br><strong>常量命名方式：全部大写，不同单词间使用下划线分割</strong></p>
<h1 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2.   标识符"></a>2.   标识符</h1><h2 id="2-1-标识符概念"><a href="#2-1-标识符概念" class="headerlink" title="2.1  标识符概念"></a>2.1  标识符概念</h2><p>Java对包、类、方法、参数和变量等要素命名时使用的字符序列称为标识符。简单理解，标识符就是程序员自己起的名字。</p>
<h2 id="2-2-命名规则"><a href="#2-2-命名规则" class="headerlink" title="2.2  命名规则"></a>2.2  命名规则</h2><p>由字母、数字、下划线（_）和美元符号（$）组成<br>不能以数字开头<br>区分大小写<br>不能是Java中的关键字和保留字</p>
<h2 id="2-3-关键字和保留字"><a href="#2-3-关键字和保留字" class="headerlink" title="2.3  关键字和保留字"></a>2.3  关键字和保留字</h2><p>关键字：Java中已使用的有专门用途的字符串<br>保留字：Java中预留的但暂未使用的字符串，如goto，const</p>
<h2 id="2-4-命名规约"><a href="#2-4-命名规约" class="headerlink" title="2.4  命名规约"></a>2.4  命名规约</h2><p>包名：多单词组成时所有字母都小写。如com.baidu.map。<br>类名、接口名：多单词组成时，所有单词的首字母大写。如AnimalDemo。<br>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写（驼峰命名法）。如stuAge。<br>常量名：所有字母都大写。多单词时每个单词用下划线连接。如PI_VALUE。</p>
<h1 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.   数据类型"></a>3.   数据类型</h1><h2 id="3-1-数据类型的作用"><a href="#3-1-数据类型的作用" class="headerlink" title="3.1  数据类型的作用"></a>3.1  数据类型的作用</h2><p>对数据进行分类管理<br>为数据申请不同的内存空间</p>
<h2 id="3-2-数据类型的分类"><a href="#3-2-数据类型的分类" class="headerlink" title="3.2  数据类型的分类"></a>3.2  数据类型的分类</h2><p>Java的数据类型分为基本类型和引用类型（复合类型）。</p>
<h2 id="3-3-整数类型（byte、short、int、long）"><a href="#3-3-整数类型（byte、short、int、long）" class="headerlink" title="3.3  整数类型（byte、short、int、long）"></a>3.3  整数类型（byte、short、int、long）</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>中文名称</th>
<th>内存大小</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>字节型</td>
<td>8位（1字节）</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>短整型</td>
<td>16位</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>32位</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>64位</td>
<td>0L</td>
</tr>
</tbody></table>
<p>整数默认是int类型<br>声明long型需要加‘l’或‘ L’<br><code>long d = 12l;</code><br><code>long d = 12L;</code></p>
<h2 id="3-4-浮点数类型（float、double）"><a href="#3-4-浮点数类型（float、double）" class="headerlink" title="3.4  浮点数类型（float、double）"></a>3.4  浮点数类型（float、double）</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>中文名称</th>
<th>内存大小</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>单精度浮点数</td>
<td>32位</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>64位</td>
<td>0.0</td>
</tr>
</tbody></table>
<p>float，后面必须加F或者f<br><code>float f1 = 3.2f;</code><br><code>float f2 = 3.5F;</code></p>
<p>double，后面可以加D或d或者不加（即浮点类型默认是double类型）<br><code>double d1 = 2.0D;</code><br><code>double d2 = 2.1d;</code><br><code>double d3 = 2.0;</code></p>
<p>浮点型精度不准确</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">10.0F</span>/<span class="number">3</span>);	<span class="comment">//	3.3333333</span></span><br><span class="line">System.out.println(<span class="number">10.0</span>/<span class="number">3</span>);	<span class="comment">//	3.3333333333333335</span></span><br></pre></td></tr></table></figure>
<p>浮点数其他表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//科学计数法</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.2E2</span>;</span><br><span class="line">System.out.println(d2);</span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="number">.12</span>;</span><br><span class="line">System.out.println(d3);</span><br></pre></td></tr></table></figure>

<h2 id="3-5-字符类型（char）"><a href="#3-5-字符类型（char）" class="headerlink" title="3.5  字符类型（char）"></a>3.5  字符类型（char）</h2><p>Java中的字符采用Unicode字符集，支持中文字符，每个字符占16位。<br>字符是用单引号包含的一个字符。</p>
<p>char c &#x3D;	‘a’；</p>
<p>char和int互相转换<br><code>char c = 97； //c = &#39;a&#39;</code><br><code>int x = &#39;a&#39;; //x = 97</code></p>
<p>转义字符</p>
<p>转义字符\，将其后的字符转变为其它的特殊含义。</p>
<table>
<thead>
<tr>
<th>转移字符</th>
<th>作用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
<td>将光标移到下一行的首位</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td>将光标移到当前行的首位</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表</td>
<td>将光标移到下一个水平制表位置，相等于按了Tab键盘</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
<td></td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
<td></td>
</tr>
<tr>
<td>\</td>
<td>斜杠</td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-6-布尔类型（boolean）"><a href="#3-6-布尔类型（boolean）" class="headerlink" title="3.6  布尔类型（boolean）"></a>3.6  布尔类型（boolean）</h2><p>布尔类型数据用来保存真与假。真为true，假为false。</p>
<h2 id="3-7-基本数据类型之间的转换"><a href="#3-7-基本数据类型之间的转换" class="headerlink" title="3.7  基本数据类型之间的转换"></a>3.7  基本数据类型之间的转换</h2><p>自动类型转换</p>
<p>容量小（低位）的类型自动转换成容量大（高位）的数据类型</p>
<p>强制类型转换</p>
<p>容量大（高位）的类型强制转换成容量小（低位）的数据类型强制类型转换有可能造成精度降低(数据溢出)</p>
<h2 id="3-8-字符串（String）"><a href="#3-8-字符串（String）" class="headerlink" title="3.8  字符串（String）"></a>3.8  字符串（String）</h2><p>字符串是用双引号包含的一串字符</p>
<p>字符串Sting属于引用类型。字符串拼接符，“+”</p>
<h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.   运算符"></a>4.   运算符</h1><h2 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1  算术运算符"></a>4.1  算术运算符</h2><p><strong>+、 - 、 * 、 &#x2F; 、 % 、 ++ 、 –</strong></p>
<p>参与运算的都是数值型数据，运算结果的数据类型以参与运算的高位为准</p>
<p>只有整数参数的除法运算结果只保留整数部分<br>除数不能为0<br>% （取余&#x2F;求模）：整数进行除法运算后的余数。</p>
<p>  ++ 和 – （自增和自减）：自身加1或者减1</p>
<p>单独使用在前在后无差别。</p>
<p>参与其他运算，在前是“先己后人”，在后是“先人后己”。</p>
<h2 id="4-2-赋值运算符"><a href="#4-2-赋值运算符" class="headerlink" title="4.2  赋值运算符"></a>4.2  赋值运算符</h2><p>赋值运算是将运算结果重新给变量赋值，比如 a +&#x3D; b，运算类似于a &#x3D; a + b。 其他运算符以此类推。<br>**&#x3D; 、 +&#x3D; 、 -&#x3D; 、 <em>&#x3D; 、 &#x2F;&#x3D; 、 %&#x3D;</em>*</p>
<h2 id="4-3-关系运算符"><a href="#4-3-关系运算符" class="headerlink" title="4.3  关系运算符"></a>4.3  关系运算符</h2><p>关系运算符又称为比较运算符，是比较两个数的大小，运算结果为布尔类型。<br><strong>&gt;、 &lt; 、 &gt;&#x3D; 、 &lt;&#x3D; 、 &#x3D;&#x3D; 、 !&#x3D;</strong><br>&#x3D;&#x3D;，判断是否相等，相等为true<br>!&#x3D;， 判断是否不等，不等为true</p>
<h2 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4  逻辑运算符"></a>4.4  逻辑运算符</h2><p>逻辑运算符是比较两个布尔类型数据的逻辑关系，运算结果依旧是布尔类型。<br><strong>&amp;、| 、! 、^、&amp;&amp;、 ||</strong><br>&amp;， 逻辑与&#x2F;单与：两边同时为true，结果为true<br>| ， 逻辑或&#x2F;单或：两边有一个为true，结果为true<br>！， 逻辑非（取反）：true变false，false变true^， 逻辑异或：两边不同为true，相同为false</p>
<p>&amp;&amp;， 短路与&#x2F;双与：两边同时为true，结果为true<br>||， 短路或&#x2F;双或：两边有一个为true，结果为true &amp;，| 和&amp;&amp; 、 ||的区别<br>&amp;，| ：左边能得到结果，右边也需要计算<br>&amp;&amp;，|| ：左边能得到结果，右边不再计算</p>
<h2 id="4-5-三元运算符"><a href="#4-5-三元运算符" class="headerlink" title="4.5  三元运算符"></a>4.5  三元运算符</h2><p>三元运算符又称三目运算符或条件运算符。<br>布尔类型表达式1 ? 表达式2 : 表达式3<br>运算法则：如果表达式1成立，则结果为表达式2，否则结果为表达式3</p>
<h2 id="4-6-位运算符"><a href="#4-6-位运算符" class="headerlink" title="4.6  位运算符"></a>4.6  位运算符</h2><p><strong>4.6.1</strong>  <strong>二进制</strong><br>计算机内部采用二进制存储数据。二进制由0和1组成，逢2进1。正数十进制转二进制：对于正数，除2倒序取余，不足用0补齐 正数二进制转十进制：对于正数，按位乘以2的n次幂</p>
<h2 id="4-6-2-按位运算"><a href="#4-6-2-按位运算" class="headerlink" title="4.6.2  按位运算"></a>4.6.2  按位运算</h2><p>按位运算是将十进制数据先转化为二进制数，再逐位（bit）按规则计算，最后将运算结果转换成十进制。</p>
<p>&amp; 、 | 、~ 、 ^<br>异或加密算法</p>
<p>异或算法是可逆的，如果对某个数据进行两次相同的异或运算，则结果会还原为数据本身。</p>
<h2 id="4-6-3-移位运算符"><a href="#4-6-3-移位运算符" class="headerlink" title="4.6.3  移位运算符"></a>4.6.3  移位运算符</h2><p><code>&gt;&gt; 、 &lt;&lt; 、 &gt;&gt;&gt;</code><br>对于正数，右移n位相当于除以2的n次幂，左移n位相当于乘以2的n次幂</p>
<h2 id="4-7-运算符优先级"><a href="#4-7-运算符优先级" class="headerlink" title="4.7  运算符优先级"></a>4.7  运算符优先级</h2><p>小括号优先级最高 赋值运算优先级最低</p>
<h1 id="5-表达式"><a href="#5-表达式" class="headerlink" title="5.   表达式"></a>5.   表达式</h1><p>表达式：表达式是符合一定语法规则的运算符和操作数的序列<br>表达式值 ：对表达式中操作数进行运算得到的结果称为表达式的值<br>表达式类型：表达式的值的数据类型即为表达式的类型 。比如 10 &gt; 20，称为布尔表达式，表达式值为false，表达式类型是布尔型。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2024/10/08/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><span id="more"></span>
<h1 id="1-异常概念"><a href="#1-异常概念" class="headerlink" title="1. 异常概念"></a>1. 异常概念</h1><h2 id="1-1-异常"><a href="#1-1-异常" class="headerlink" title="1.1 异常"></a>1.1 异常</h2><p>异常是程序在<strong>编译</strong>或<strong>运行</strong>期间发生的不正常的事件。异常会打断指令的正常执行流程，如int i &#x3D; 1&#x2F;0。</p>
<h2 id="1-2-异常处理"><a href="#1-2-异常处理" class="headerlink" title="1.2 异常处理"></a>1.2 异常处理</h2><p>异常处理是指在异常发生时处理这些不正常事件的方法。异常处理可以使程序不会因为异常的发生而阻断或产生不可预见的结果。</p>
<h1 id="2-异常体系结构"><a href="#2-异常体系结构" class="headerlink" title="2. 异常体系结构"></a>2. 异常体系结构</h1><h2 id="2-1-错误和异常"><a href="#2-1-错误和异常" class="headerlink" title="2.1 错误和异常"></a>2.1 错误和异常</h2><p>错误(Error)</p>
<p>因JVM系统原因导致的问题，属于JVM需要负担的责任这一类异常事件无法恢复或不可能捕获，将导致应用程序中断。</p>
<p>异常(Exception)</p>
<p>因代码原因导致的一般性问题。这类异常得到恰当的处理时，程序有机会恢复至正常运行状况。程序员通常只能处理异常(Exception)。</p>
<h2 id="2-2-编译时异常和运行时异常（RunTimeException）"><a href="#2-2-编译时异常和运行时异常（RunTimeException）" class="headerlink" title="2.2 编译时异常和运行时异常（RunTimeException）"></a>2.2 编译时异常和运行时异常（RunTimeException）</h2><h3 id="2-2-1-概念"><a href="#2-2-1-概念" class="headerlink" title="2.2.1 概念"></a>2.2.1 概念</h3><p>编译时异常（受检异常）：必须处理，否则编译不通过</p>
<p>运行时异常（RuntimeException）：编译可通过，在运行时报错</p>
<h3 id="2-2-2-常见的编译时异常"><a href="#2-2-2-常见的编译时异常" class="headerlink" title="2.2.2 常见的编译时异常**"></a>2.2.2 常见的编译时异常**</h3><p>java.lang.ClassNotFoundException：没有找到指定名称的类</p>
<p>java.io.FileNotFoundException ：访问不存在的文件</p>
<p>java.io.IOException：操作文件时发生的异常</p>
<p>java.sql.1：操作数据库时发生的异常</p>
<h3 id="2-2-3-常见的运行时异常"><a href="#2-2-3-常见的运行时异常" class="headerlink" title="2.2.3 常见的运行时异常"></a>2.2.3 常见的运行时异常</h3><p>java.lang.ClassCastException：错误的类型转换</p>
<p>java.lang.ArrayIndexOutOfBoundsException：数组下标越界</p>
<p>java.lang.NullPointerException：空指针访问</p>
<p>java.lang.ArithmeticException：算术异常(除0溢出)</p>
<h1 id="3-异常处理机制"><a href="#3-异常处理机制" class="headerlink" title="3. 异常处理机制"></a>3. 异常处理机制</h1><h2 id="3-1-抛出-throw-异常"><a href="#3-1-抛出-throw-异常" class="headerlink" title="3.1 抛出(throw)异常"></a>3.1 抛出(throw)异常</h2><p>Java程序在执行过程中如果出现异常，会自动生成一个异常类对象，该异常对象将被自动提交给JVM，这个过程称为抛出(throw)异常。</p>
<h2 id="3-2-捕获-catch-异常和处理异常"><a href="#3-2-捕获-catch-异常和处理异常" class="headerlink" title="3.2 捕获(catch)异常和处理异常"></a>3.2 捕获(catch)异常和处理异常</h2><p>当JVM接收到异常对象时，会寻找能处理这一异常的代码并把当前异常对象交给其处理，这一过程称为捕获(catch)异常和处理异常。</p>
<p>如果JVM找不到可以捕获和处理异常的代码（也就是程序员没有处理），则默认处理方式是系统将终止，相应的Java程序也将退出。</p>
<h1 id="4-异常处理方式"><a href="#4-异常处理方式" class="headerlink" title="4. 异常处理方式"></a>4. 异常处理方式</h1><h2 id="4-1-代码捕获异常（try-catch-finally）"><a href="#4-1-代码捕获异常（try-catch-finally）" class="headerlink" title="4.1 代码捕获异常（try-catch-finally）"></a>4.1 代码捕获异常（try-catch-finally）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">  ...... <span class="comment">//可能产生异常的代码</span></span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span>( ExceptionName1 e )&#123;</span><br><span class="line"></span><br><span class="line">  ...... <span class="comment">//异常的处理代码</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>( ExceptionName2 e )&#123;</span><br><span class="line"></span><br><span class="line">  ...... <span class="comment">//异常的处理代码</span></span><br><span class="line"></span><br><span class="line">&#125;  [ <span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">   ...... <span class="comment">//无论如何都会执行的语句</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;  ] </span><br></pre></td></tr></table></figure>
<p>try 代码段包含的是可能产生异常的代码，能确定不会产生异常的代码不要放入try中。</p>
<p>当异常发生时，程序会中止当前的流程去执行相应的catch代码段。</p>
<p>先捕获的异常的范围不能大于后捕获的异常的范围。</p>
<p>finally段的代码无论是否发生异常都执行。</p>
<p>JDK7 之后如果多个异常处理方式一致，可以统一处理。一个catch代码可以可以声明多个能处理的特定异常的类型，多个类型之间用”|”隔开。</p>
<p>catch( ExceptionName1 e | ExceptionName2 e){</p>
<p>   …… &#x2F;&#x2F;异常的处理代码</p>
<p>}</p>
<h2 id="4-2-方法抛出异常类型（throws）"><a href="#4-2-方法抛出异常类型（throws）" class="headerlink" title="4.2 方法抛出异常类型（throws）"></a>4.2 方法抛出异常类型（throws）</h2><p>使用throws声明方法，此方法本身不处理异常，而交给方法的调用者进行处理。</p>
<p> [访问权限修饰符] 返回值类型 方法名(参数列表) throws 异常类,异常类{ }</p>
<p>​    回忆：方法的重写要求</p>
<h1 id="5-异常常用方法"><a href="#5-异常常用方法" class="headerlink" title="5. 异常常用方法"></a>5. 异常常用方法</h1><p>printStackTrace();  向控制台打印异常信息</p>
<p>public String getMessage()  返回此throwable的详细消息字符串</p>
<h1 id="6-自定义异常"><a href="#6-自定义异常" class="headerlink" title="6. 自定义异常"></a>6. 自定义异常</h1><h2 id="6-1-使用场景"><a href="#6-1-使用场景" class="headerlink" title="6.1 使用场景"></a>6.1 使用场景</h2><p>在某些情况下，代码符合java语法要求，但不符合业务逻辑。比如设置年龄为负数，此时可以使用自定义异常处理。</p>
<h2 id="6-2-自定义异常"><a href="#6-2-自定义异常" class="headerlink" title="6.2 自定义异常"></a>6.2 自定义异常</h2><p>继承Exception 或其子类。习惯上包装一下父类的构造方法，重写异常信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String msg)</span> &#123; </span><br><span class="line"></span><br><span class="line">​     <span class="built_in">super</span>(msg); </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-抛出自定义异常对象（throw）"><a href="#6-3-抛出自定义异常对象（throw）" class="headerlink" title="6.3 抛出自定义异常对象（throw）"></a>6.3 抛出自定义异常对象（throw）</h2><p>异常不仅仅虚拟机可以抛，我们自己也可以抛。在某些特殊条件满足的情况下使用throw关键字，来抛出某个具体的异常对象。</p>
<p>手动抛出异常后，必须要处理它。一般处理方式是方法抛出异常，让调用者处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (age &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄小于0,不合法&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>6.4 案例：判断登录状态，如精确判断登录成功及失败原因（用户名不存在或者密码错误）</strong></p>
<p><strong>7. debug</strong></p>
<p>​    bug，中文含义“臭虫”，程序开发中是指错误。</p>
<p>Debug称为调试，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p>
<p><strong>7.1 断点（breakpoint）</strong></p>
<p>程序在dubug模式运行，碰到断点会停止运行。</p>
<p>在代码行号前右键，选择Toggle Breakpoint（或在行号前双击左键），可以实现添加和删除断点。</p>
<p><strong>7.2 快捷键</strong></p>
<p>F5（Step Into）：单步执行，遇到子函数就进入并且继续单步执行，表示进入当前方法。快捷键为</p>
<p>F6（Step Over）：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完在停止，也就是把子函数整个作为一步，表示运行下一行代码。</p>
<p>F7（Step Return） ：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完在停止，也就是把子函数整个作为一步，表示退出当前方法，返回到调用层。</p>
<p>F8（Resume）：恢复暂停的线程，直接从当前位置跳到下一个断点位置，表示当前实现继续运行直到下一个断点。</p>
<p><strong>8. JUnit</strong></p>
<p>JUnit是适用于Java语言的单元测试框架。办法分为JUnit4和JUnit5，用法类似。</p>
<p><strong>8.1 JUnit5常用注解</strong></p>
<p>所有方法必须是void的无参方法</p>
<p>@BeforeAll，在所有单元测试用例前执行，只执行一次，必须是静态方法</p>
<p>@AfterAll，在所有单元测试用例后执行，只执行一次，必须是静态方法</p>
<p>@BeforeEach，在每个单元测试用例前执行</p>
<p>@AfterEach，在每个单元测试用例后执行</p>
<p>@Test，单元测试</p>
<p><strong>8.2 断言</strong></p>
<p>单元测试Assertions类提供了各种assertXX()方法，可以实现结果预判断</p>
<p>assertEquals(1+1, 2);</p>
<p>assertNotEquals(“a”+”b”, “abc”);</p>
<p>assertSame(“abc”, “abc”);</p>
<p>assertNotSame(new Book(), new Book());</p>
<p>assertNull(null);</p>
<p>assertNotNull(new Book());</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2024/10/03/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="java的数据类型"><a href="#java的数据类型" class="headerlink" title="java的数据类型"></a>java的数据类型</h1><span id="more"></span>
<p>基本类型：8个基本类型。 类型首字母小写</p>
<p>引用类型： 对象类型。</p>
<h2 id="1-1-八个基本类型"><a href="#1-1-八个基本类型" class="headerlink" title="1.1 八个基本类型"></a>1.1 八个基本类型</h2><p> &#x2F;&#x2F; 0开头时8进制， 0b时二进制， 0x十六进制</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>byte 字节</td>
<td>8位，   8bit</td>
<td>-128-127<br />0111 1111     127<br /><br />1000 0000     -128</td>
<td>网络传输，文件的大小</td>
</tr>
<tr>
<td>short 短整型</td>
<td>2byte  16位</td>
<td>（-2的n-1次方~2的n-1次方-1）</td>
<td>16位计算机用</td>
</tr>
<tr>
<td>int 整型</td>
<td>4byte  32位</td>
<td></td>
<td>字面量</td>
</tr>
<tr>
<td>long 长整型</td>
<td>8byte  64位</td>
<td></td>
<td>毫秒数（1970-1-1凌晨到现在的毫秒数）</td>
</tr>
<tr>
<td>float 单精度浮点型</td>
<td>32位</td>
<td>默认大于整数</td>
<td>有效位数8位</td>
</tr>
<tr>
<td>double双精度浮点型</td>
<td>64</td>
<td></td>
<td>字面量。 浮点型都<code>不能</code>参与运算</td>
</tr>
<tr>
<td>boolean布尔型</td>
<td>1bit</td>
<td>true, false</td>
<td></td>
</tr>
<tr>
<td>char字符型</td>
<td>2byte 16位</td>
<td></td>
<td>和整数隐式转换， 可以参与运算</td>
</tr>
</tbody></table>
<h2 id="1-2-字符型"><a href="#1-2-字符型" class="headerlink" title="1.2 字符型"></a>1.2 字符型</h2><ul>
<li>ASCII码: 1byte范围 0~127</li>
</ul>
<p>0: 空字符<code> ‘’</code></p>
<p>32: 空格 <code>&#39; &#39;</code></p>
<p>49:  字符<code>&#39;1&#39;</code></p>
<p>65: ‘A’</p>
<p>97: ‘a’</p>
<ul>
<li>转义字符：</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">\&#x27;   \&quot;  \r  \n  \t   \\</span><br></pre></td></tr></table></figure>

<ul>
<li>Unicode码：  <code>\uFFFF</code> 四个十六进制数表示 两个字节的字符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 定义byte型变量时 a1</span></span><br><span class="line">		<span class="type">byte</span> a1;</span><br><span class="line">		<span class="comment">// （编译时隐式转换） </span></span><br><span class="line">		a1 = <span class="number">127</span>; <span class="comment">// 0开头时8进制， 0b时二进制， 0x十六进制</span></span><br><span class="line">		<span class="comment">// byte a2 = 128; 超过范围</span></span><br><span class="line">		System.out.println(a1);</span><br><span class="line">		<span class="type">short</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="number">1024</span>; <span class="comment">// 字面量常亮数值1024 默认时int型的</span></span><br><span class="line">		System.out.println(a3);		</span><br><span class="line">		<span class="type">long</span> <span class="variable">a4</span> <span class="operator">=</span> <span class="number">120</span>; <span class="comment">// 120 是32位</span></span><br><span class="line">		a4 = <span class="number">120L</span>; <span class="comment">// 120L 是64位</span></span><br><span class="line">		System.out.println(a4);</span><br><span class="line">		System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line">		<span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.12345678901234567f</span>;</span><br><span class="line">		System.out.println(f);</span><br><span class="line">		<span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0.12345678901234567</span>;</span><br><span class="line">		System.out.println(d);</span><br><span class="line">		System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line">		System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		System.out.println(a + <span class="number">0</span>);</span><br><span class="line">		<span class="type">char</span> <span class="variable">a5</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">		System.out.println( (<span class="type">char</span>)a5 );</span><br><span class="line">		<span class="type">char</span> <span class="variable">a6</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		System.out.println(a6 + <span class="number">0</span>);</span><br><span class="line">		System.out.println( (<span class="type">char</span>) <span class="number">57</span>);</span><br><span class="line">		System.out.println( <span class="string">&#x27;A&#x27;</span> &gt; <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line">		System.out.println( <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">		System.out.println( <span class="string">&#x27;	&#x27;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">char</span> <span class="variable">a7</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		System.out.println(a7);</span><br><span class="line">		</span><br><span class="line">		<span class="type">char</span> <span class="variable">a8</span> <span class="operator">=</span> <span class="string">&#x27;丁&#x27;</span>;</span><br><span class="line">		System.out.println(a8 + <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">char</span> <span class="variable">a9</span> <span class="operator">=</span> <span class="string">&#x27;\u4E01&#x27;</span>; <span class="comment">// Unicode码</span></span><br><span class="line">		System.out.println(a9);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-基本类型转换"><a href="#1-3-基本类型转换" class="headerlink" title="1.3 基本类型转换"></a>1.3 基本类型转换</h2><p>小 转 大  隐式</p>
<p>大 转 小  强制转换<code>a = (byte) b;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">b = a; <span class="comment">// 小 转 大  隐式</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">11</span>;</span><br><span class="line">a = (<span class="type">byte</span>) b; <span class="comment">// 大 转 小  强制转换</span></span><br><span class="line">System.out.println(a);</span><br><span class="line"></span><br><span class="line">a = (<span class="type">byte</span>) <span class="number">128</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line">a = (<span class="type">byte</span>) <span class="number">1234</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 32int ===&gt; 32浮点</span></span><br><span class="line"><span class="type">long</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a1 = (<span class="type">long</span>) f1; <span class="comment">// 32浮点  ===&gt; 64long </span></span><br></pre></td></tr></table></figure>
















]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2024/10/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2024/10/08/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><span id="more"></span>
<h1 id="1-数组概念"><a href="#1-数组概念" class="headerlink" title="1. 数组概念"></a>1. 数组概念</h1><h2 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h2><p>用来存储一组相同类型数据的数据结构，如{1, 2, 3}，{“aa”, “bb”}</p>
<p>数组本身属于引用数据类型</p>
<h2 id="1-2-元素"><a href="#1-2-元素" class="headerlink" title="1.2 元素"></a>1.2 元素</h2><p>数组中存储的数据称为元素</p>
<p>元素可以是任何数据类型</p>
<h2 id="1-3-数组长度"><a href="#1-3-数组长度" class="headerlink" title="1.3 数组长度"></a>1.3 数组长度</h2><p>数组元素的个数称为数组的长度</p>
<p>数组创建好之后，长度是不能改变的</p>
<h2 id="1-4-下标-索引"><a href="#1-4-下标-索引" class="headerlink" title="1.4 下标&#x2F;索引**"></a>1.4 下标&#x2F;索引**</h2><p>下标又称为索引，是指元素在数组中的位置</p>
<p>下标从0开始</p>
<h1 id="2-静态创建"><a href="#2-静态创建" class="headerlink" title="2. 静态创建**"></a>2. 静态创建**</h1><p>数组使用[]表示，所谓静态创建是指在创建数组的同时对数组元素进行初始化赋值。</p>
<p>元素的数据类型[]  数组变量名 &#x3D; 数组常量。</p>
<p>int[] array &#x3D; {1, 2, 3};</p>
<p>[]的位置在变量名前后都可以，如int array[]，但是规范写法在前。</p>
<h1 id="3-数组使用"><a href="#3-数组使用" class="headerlink" title="3. 数组使用**"></a>3. 数组使用**</h1><h2 id="3-1-获得数组长度"><a href="#3-1-获得数组长度" class="headerlink" title="3.1 获得数组长度"></a>3.1 获得数组长度</h2><p>**通过length属性获得数组长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length; <span class="comment">//len = 3</span></span><br></pre></td></tr></table></figure>


<h2 id="3-2-数组元素的访问"><a href="#3-2-数组元素的访问" class="headerlink" title="3.2 数组元素的访问"></a>3.2 数组元素的访问</h2><h3 id="通过数组元素的下标获得数组元素"><a href="#通过数组元素的下标获得数组元素" class="headerlink" title="通过数组元素的下标获得数组元素"></a>通过数组元素的下标获得数组元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> array[<span class="number">2</span>]; <span class="comment">//item = 3</span></span><br></pre></td></tr></table></figure>
<p>如果下标超过范围，会出现数组下标越界的异常( ArrayIndexOutOfBoundsException)</p>
<h2 id="3-3-循环遍历"><a href="#3-3-循环遍历" class="headerlink" title="3.3 循环遍历"></a>3.3 循环遍历</h2><p>普通for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123; <span class="comment">// i 是数组的下标</span></span><br><span class="line"></span><br><span class="line">  System.out.println(array[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增强for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : array) &#123; <span class="comment">// item 是数组的元素</span></span><br><span class="line"></span><br><span class="line">  System.out.println(item);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="4-动态创建"><a href="#4-动态创建" class="headerlink" title="4. 动态创建**"></a>4. 动态创建**</h1><p>数组的内存存储方式</p>
<p>数组变量（引用）本身存储在栈内存中，而实际的数据内容存储在堆内存中</p>
<p>数组声明</p>
<p>声明数组时只是指明数组元素的类型，没有指定数组的大小，也没有给数组分配存储数据的内存空间。</p>
<p><strong>数组元素类型[] 数组名;</strong></p>
<p>String[]  names;</p>
<p>数组初始化</p>
<p><strong>数组名 &#x3D; new 数组元素类型[数组长度];</strong></p>
<p><strong>数组元素的初始值是其元素类型的默认初始值。</strong></p>
<p>names &#x3D; new String[10];</p>
<p>System.out.println(names[0]);</p>
<p>元素赋值</p>
<p>names[0] &#x3D; “小张”；</p>
<h1 id="5-二维数组"><a href="#5-二维数组" class="headerlink" title="5. 二维数组"></a>5. 二维数组</h1><h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h2><p>一维数组中的每个元素又是一个一维数组</p>
<p>{1, 2, 3}  &#x2F;&#x2F;一维数组</p>
<p>{      &#x2F;&#x2F;二维数组</p>
<p>   {1, 1}, </p>
<p>   {2, 2}, </p>
<p>   {3, 3}</p>
<p>} </p>
<h2 id="5-2-二维数组的声明"><a href="#5-2-二维数组的声明" class="headerlink" title="5.2 二维数组的声明**"></a>5.2 二维数组的声明**</h2><p>语法格式：</p>
<p>int[][] array; </p>
<h2 id="5-3-二维数组的初始化"><a href="#5-3-二维数组的初始化" class="headerlink" title="5.3 二维数组的初始化**"></a>5.3 二维数组的初始化**</h2><p>规则数组，规定行数和列数</p>
<p>array &#x3D; new int[3][2];  &#x2F;&#x2F;第一个中括号[]声明行数，第二个中括号[]声明每行列数</p>
<p>不规则数组，只规定最外层行数，在分别指定每行的列数</p>
<p>array &#x3D; new int[3][];</p>
<p>array[0] &#x3D; new int[2];</p>
<p>array[1] &#x3D; new int[3];</p>
<p>array[2] &#x3D; new int[4];</p>
<h2 id="5-4-二维数组的赋值"><a href="#5-4-二维数组的赋值" class="headerlink" title="5.4 二维数组的赋值**"></a>5.4 二维数组的赋值**</h2><p>通过下标给每个元素单独赋值</p>
<p>int[][] array &#x3D; new int[3][2];</p>
<p>arryay[0][0] &#x3D; 2;</p>
<h2 id="5-5-二维数组的访问"><a href="#5-5-二维数组的访问" class="headerlink" title="5.5 二维数组的访问**"></a>5.5 二维数组的访问**</h2><p>行数</p>
<p>array.length</p>
<p>每行列数</p>
<p>array[0].length</p>
<p>循环访问二维数组元素</p>
<p>int[][] array &#x3D; {      </p>
<p>​           {1, 1}, </p>
<p>​           {2, 2}, </p>
<p>​           {3, 3}</p>
<p>​        };</p>
<p>for (int i &#x3D; 0; i &lt; array.length; i++) {</p>
<p>  for (int j &#x3D; 0; j &lt; array[i].length; j++) {</p>
<p>​    System.out.print(array[i][j] + “, “);</p>
<p>  }</p>
<p>  System.out.println();</p>
<p>}</p>
<h1 id="6-数组排序"><a href="#6-数组排序" class="headerlink" title="6. 数组排序"></a>6. 数组排序</h1><h2 id="6-1-冒泡排序"><a href="#6-1-冒泡排序" class="headerlink" title="6.1 冒泡排序"></a>6.1 冒泡排序</h2><p>每位数字依次和后面的数字比较，小的互换位置。</p>
<p>优点：简单</p>
<p>int[] array &#x3D; {1, 0, 3, 5, 2};</p>
<p>for (int i &#x3D; 0; i &lt; array.length - 1; i++) { &#x2F;&#x2F;对数组元素遍历</p>
<p>  for (int j &#x3D; i+1; j &lt; array.length; j++) { &#x2F;&#x2F;每个元素依次和后面的比较，一直比较到最后一个</p>
<p>​    if (array[i] &gt; array[j]) { &#x2F;&#x2F;如果前面数大</p>
<p>​      int temp &#x3D; array[i];</p>
<p>​      array[i] &#x3D; array[j];</p>
<p>​      array[j] &#x3D; temp;</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<h2 id="6-2-选择排序"><a href="#6-2-选择排序" class="headerlink" title="6.2 选择排序"></a>6.2 选择排序</h2><p>每位数字依次和后面的数字比较，记录小的位置，最后和该位数字互换</p>
<p>优点：比冒泡排序减少了替换次数</p>
<p>int[] array &#x3D; {1, 0, 3, 5, 2};</p>
<p>for (int i &#x3D; 0; i &lt; array.length - 1; i++) { &#x2F;&#x2F;对数组元素遍历</p>
<p>  int minIndex &#x3D; i; &#x2F;&#x2F;假设当前最小</p>
<p>  for (int j &#x3D; i+1; j &lt; array.length; j++) { &#x2F;&#x2F;每个元素依次和后面的比较，一直比较到最后一个</p>
<p>​    if (array[minIndex] &gt; array[j]) { &#x2F;&#x2F;如果前面数大</p>
<p>​      minIndex &#x3D; j; &#x2F;&#x2F;重写记录最小位置</p>
<p>​    }</p>
<p>  }      </p>
<p>  if (i !&#x3D; minIndex) {&#x2F;&#x2F;i和最小位置替换</p>
<p>​    int temp &#x3D; array[i];</p>
<p>​    array[i] &#x3D; array[minIndex];</p>
<p>​    array[minIndex] &#x3D; temp;</p>
<p>  }</p>
<p>}</p>
<h2 id="6-3-插入排序"><a href="#6-3-插入排序" class="headerlink" title="6.3 插入排序"></a>6.3 插入排序</h2><p>从第二位开始，每位和前面的数字比较，如果大结束，如果小则替换。</p>
<p>优点：对于相对有序数组，替换次数较少</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;array.length; i++) &#123; <span class="comment">//从第二位开始遍历到最后</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>; j &gt;=<span class="number">0</span>; j--) &#123; <span class="comment">//依次和前面的数比较</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (array[minIndex] &gt;= array[j]) &#123;<span class="comment">//如果后面数大，则结束</span></span><br><span class="line"></span><br><span class="line">​      <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">​    &#125; </span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[minIndex]; <span class="comment">//如果后面的小，则交换并记录最小位置</span></span><br><span class="line"></span><br><span class="line">​    array[minIndex] = array[j];</span><br><span class="line"></span><br><span class="line">​    array[j] = temp;</span><br><span class="line"></span><br><span class="line">​    minIndex = j;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-4-java-util-Arrays-数组操作工具类"><a href="#6-4-java-util-Arrays-数组操作工具类" class="headerlink" title="6.4** **java.util.Arrays  数组操作工具类"></a>6.4** **java.util.Arrays  数组操作工具类</h2><p>public static void sort(int[] array)</p>
<p>经过调优的快速排序法</p>
<h1 id="7-元素查找"><a href="#7-元素查找" class="headerlink" title="7. 元素查找"></a>7. 元素查找</h1><h2 id="7-1-顺序查找"><a href="#7-1-顺序查找" class="headerlink" title="7.1 顺序查找"></a>7.1 顺序查找</h2><p>遍历数组，从数组中第一个元素开始查找。最简单，平均效率低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入要查找的数：&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">sc.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//默认找不到</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (array[i] == num) &#123;</span><br><span class="line"></span><br><span class="line">​    index = i; <span class="comment">//找到给下标赋值并退出循环</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(index);</span><br></pre></td></tr></table></figure>


<h2 id="7-2-二分法查找"><a href="#7-2-二分法查找" class="headerlink" title="7.2 二分法查找"></a>7.2 二分法查找</h2><p>使用二分查找法的前提是数组必须是有序的，原理是反复和中间值比较。</p>
<h2 id="7-3-java-util-Arrays-数组操作工具类"><a href="#7-3-java-util-Arrays-数组操作工具类" class="headerlink" title="7.3 java.util.Arrays  数组操作工具类"></a>7.3 java.util.Arrays  数组操作工具类</h2><p>public static int binarySearch(int[] array, int key)</p>
<p>使用二分搜索法</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2024/10/08/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><span id="more"></span>
<h1 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1. 泛型"></a>1. 泛型</h1><p><strong>泛型是JDK1.5提出的新特效，核心优点如下代码复用减少拆箱和装箱，提高效率和类型安全</strong></p>
<h2 id="1-1-泛型类"><a href="#1-1-泛型类" class="headerlink" title="1.1  泛型类"></a>1.1  泛型类</h2><p>关于泛型的理解先看一个案例，定义一个简单的Box类存放字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(String obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.obj = obj;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getObj</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">(String obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.obj = obj;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的Box类里面现在只能装入String类型的元素，今后如果我们需要装入Integer等其他类型的元素，还必须要另外重写一个Box，代码得不到复用。如果将String改成Object，又会涉及类型转换的问题。很多初学者在封装工具类的时候，为了达到通用型，会采用Object的方式，其实这样做是不对的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.obj = obj;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getObj</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.obj = obj;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的问题可以采用泛型类的方式加以处理。泛型类的写法是在类名后面加上 <T> ，这里的T是泛型形参，可以代表任意的引用类型。使用该类的时候，必须指明具体的引用类型，即泛型实参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T obj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(T obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.obj = obj;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getObj</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">(T obj)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.obj = obj;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> box.getObj();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Box&lt;Integer&gt; box2 = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">obj2</span> <span class="operator">=</span> box2.getObj();</span><br></pre></td></tr></table></figure>


<p>泛型不支持基本数据类型，只能是引用类型</p>
<p>泛型可以有多个，用逗号分隔，如&lt;T,V&gt;等</p>
<p>泛型形参可以使用T、E、K、V等形式，一般根据意义来选择</p>
<p>T： Type（类型）</p>
<p>E： Element (元素)</p>
<p>K： Key（键）</p>
<p>V： Value（值）</p>
<p>N： Number（数值类型）</p>
<h2 id="1-2-泛型方法"><a href="#1-2-泛型方法" class="headerlink" title="1.2 泛型方法"></a>1.2 泛型方法</h2><p>泛型方法的实现方式也比较简单，只需要在方法返回类型前面加上泛型形参即可。 泛型方法使得该方法能独立于类而产生变化。如果使用泛型方法可以取代将整个类泛型化，那么建议只使用泛型方法。</p>
<p>public static <T> void show(T t) {</p>
<p>  System.out.println(t);</p>
<p>}</p>
<h2 id="1-3-泛型接口"><a href="#1-3-泛型接口" class="headerlink" title="1.3 泛型接口"></a>1.3 泛型接口</h2><p>在实际开发中，泛型最多的应用场景应该是在接口中使用了，我们称为泛型接口。比如当我们定义Person类或者Animal类的使用，都有eat的动作，我们会把eat的行为抽象成接口。但吃什么不确定，这个时候就可以使用上泛型接口了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEatable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">IEatable</span>&lt;Mouse&gt;&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Mouse t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;猫吃&quot;</span> + t);  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-4-类型擦除"><a href="#1-4-类型擦除" class="headerlink" title="1.4 类型擦除"></a>1.4 类型擦除</h2><p>泛型只在编译过程有效，成功编译过后的class文件中是不包含任何泛型信息的。</p>
<p>看下面的例子：返回结果为true，原因在于编译时Box<String> 和 Box<Integer> 的类型都被擦除了，编译后只有Box类型。</p>
<p>Box<String> b1 &#x3D; new Box<String>(“abc”);</p>
<p>Box<Integer> b2 &#x3D; new Box<Integer>(2);</p>
<p>System.out.println(b1.getClass() &#x3D;&#x3D; b2.getClass());</p>
<h2 id="1-5-通配符"><a href="#1-5-通配符" class="headerlink" title="1.5 通配符"></a>1.5 通配符</h2><pre><code>在使用泛型作为参数的时候，可以用通配符 **?** 来表示未知类型，如Box&lt;?&gt;就声明了Box中包含的元素类型是未知的。 
</code></pre>
<p><strong>Box&lt;?&gt;并不等同于Box<Object>。</strong></p>
<p><strong>Box<Object>实际上确定了Box中包含的是Object，在使用的时候必须通过Object来进行引用。</strong></p>
<p><strong>而Box&lt;?&gt;则其中所包含的元素类型是不确定。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">   Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">   show(box); <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Box&lt;Object&gt; box)</span> &#123;</span><br><span class="line"></span><br><span class="line">   System.out.println(box);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">修改如下，将方法参数的Box&lt;Object&gt;改成Box&lt;?&gt;即可。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Box&lt;?&gt; box)</span> &#123;</span><br><span class="line"></span><br><span class="line">   System.out.println(box);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>通配符与上下限</strong></p>
<p>？：通配符，可以接收任意引用类型</p>
<p>？extends E：上限通配符，可以接收E类型或者E的子类型</p>
<p>？super E：下限通配符，可以接收E类型或者E的父类型</p>
<h1 id="2-集合概述"><a href="#2-集合概述" class="headerlink" title="2. 集合概述"></a>2. 集合概述</h1><h2 id="2-1-数组和集合的区别"><a href="#2-1-数组和集合的区别" class="headerlink" title="2.1 数组和集合的区别"></a>2.1 数组和集合的区别</h2><p>数组：长度是不可改变的，可以存放任意类型的数据。</p>
<p>集合：大小是可变的，只能存引用类型的数据。</p>
<h2 id="2-2-集合体系结构"><a href="#2-2-集合体系结构" class="headerlink" title="2.2 集合体系结构"></a>2.2 集合体系结构</h2><p><strong>两大家族</strong></p>
<p>Collection(接口)，存储的是单一对象。</p>
<p>Map(接口)，存储的是key-value(键值对)形式的数据。</p>
<p><strong>三个辅助</strong></p>
<p>Iterator(迭代器)，主要用于遍历Colleciton</p>
<p>Collecitons(工具类)，Colleciton集合的工具类</p>
<p>Comparator&#x2F;Comparable(比较器)， 用于对象之间的比较排序</p>
<h1 id="3-Collection"><a href="#3-Collection" class="headerlink" title="3. Collection"></a>3. Collection</h1><p>Collection存储的是单一对象，接口中定义了操作对象的基本方法。</p>
<h2 id="3-1-Collection子接口"><a href="#3-1-Collection子接口" class="headerlink" title="3.1 Collection子接口"></a>3.1 Collection子接口</h2><p>List：集合的元素<strong>有序允许重复</strong></p>
<p>Set：集合的元素<strong>无序不允许重复</strong></p>
<p>Queue：集合的元素以队列的数据结构存储。</p>
<h2 id="3-2-常用方法"><a href="#3-2-常用方法" class="headerlink" title="3.2 常用方法"></a>3.2 常用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E element)</td>
<td>向集合添加元素</td>
</tr>
<tr>
<td>boolean addAll(Collection  c)</td>
<td>向集合添加另外集合的元素</td>
</tr>
<tr>
<td>boolean remove(E element)</td>
<td>从集合中移除指定的元素</td>
</tr>
<tr>
<td>boolean removeAll(Collection  c)</td>
<td>从集合中移除另外集合的元素</td>
</tr>
<tr>
<td>boolean contains(E element)</td>
<td>判断此集合是否包含指定的元素</td>
</tr>
<tr>
<td>boolean containsAll(Collection  c)</td>
<td>判断此集合是否包含另外集合的元素</td>
</tr>
<tr>
<td>void clear()</td>
<td>移除此集合中所有的元素</td>
</tr>
<tr>
<td>int size()</td>
<td>返回此集合中的元素数</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断此集合是否为空</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>把此集合转成数组</td>
</tr>
<tr>
<td>Iterator iterator()</td>
<td>返回在此集合的迭代器</td>
</tr>
</tbody></table>
<h1 id="4-List"><a href="#4-List" class="headerlink" title="4. List"></a>4. List</h1><p>List集合中的元素是允许重复。List集合中的每个元素都有索引，索引从0开始。</p>
<h2 id="4-1-List子类"><a href="#4-1-List子类" class="headerlink" title="4.1 List子类"></a>4.1 List子类</h2><p>ArrayList</p>
<p>ArrayList底层使用<strong>数组结构</strong>实现，读取效率高，删除和添加效率低。</p>
<p>原理：ArrayList使用连续的内存单元存储数据元素，当添加或删除数据元素时，ArrayList需要移动其被添加（或删除）元素后面的全部元素，因此效率较低。在遍历所有元素方面，ArrayList具有很好的效率，因为其数据元素的连续性，所有只需要获取到第一个元素的地址，再使用地址指针下移的方式即可获取全部元素。</p>
<p>LinkedList</p>
<p>LinkedList是使用<strong>双向链表</strong>实现的集合。读取效率低，删除和添加效率高。</p>
<p>原理：LinkedList是使用指针关联的双向链表，其获取下一个元素的方式是通过指向下一个元素的地址对象获取的，由于它的链式存储结构，LinkedList在任意位置的元素插入（或删除）效率都比较快，因为元素插入（或删除）不需要移动集合中的其它元素。由于存储数据单元的内存地址不连续，因此遍历元素效率比较低。</p>
<p>Vector</p>
<p>Vector称为向量，是线程安全的效率低。Vector提供一个Stack子类，它模拟了“<strong>栈</strong>”这种数据结构，“栈”通常是指“后进先出”（LIFO）。</p>
<h2 id="4-2-构造方法"><a href="#4-2-构造方法" class="headerlink" title="4.2 构造方法"></a>4.2 构造方法</h2><table>
<thead>
<tr>
<th><strong>构造方法</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public  ArrayList()</td>
<td>构造一个空列表。</td>
</tr>
<tr>
<td>public  ArrayList(int  initialCapacity)</td>
<td>构造具有指定初始容量的空列表。</td>
</tr>
<tr>
<td>ArrayList(Collection&lt;?  extends E&gt; c)</td>
<td>构造一个包含指定集合元素的列表，按照它们由集合的迭代器返回的顺序。</td>
</tr>
</tbody></table>
<h2 id="4-3-新增方法"><a href="#4-3-新增方法" class="headerlink" title="4.3 新增方法"></a>4.3 新增方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index, E  element)</td>
<td>在列表的指定位置插入元素</td>
</tr>
<tr>
<td>E set(int index, E new)</td>
<td>用指定元素替换列表中指定位置的元素</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>移除列表中指定位置的元素</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>返回列表中的元素数</td>
</tr>
</tbody></table>
<h2 id="4-4-遍历"><a href="#4-4-遍历" class="headerlink" title="4.4 遍历"></a>4.4 遍历</h2><p>普通for循环</p>
<p>增强for循环</p>
<p>java8的forEach循环</p>
<p>迭代器</p>
<h2 id="4-5-LinkedList新增方法"><a href="#4-5-LinkedList新增方法" class="headerlink" title="4.5 LinkedList新增方法"></a>4.5 LinkedList新增方法</h2><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public  void addFirst(E e)</td>
<td>将指定元素插入此列表的开头</td>
</tr>
<tr>
<td>public  void addLast(E e)</td>
<td>将指定元素添加到此列表的结尾</td>
</tr>
<tr>
<td>public  E getFirst()</td>
<td>返回此列表的第一个元素</td>
</tr>
<tr>
<td>public  E  getLast()</td>
<td>返回此列表的最后一个元素</td>
</tr>
<tr>
<td>public E removeFirst()</td>
<td>移除并返回此列表的第一个元素</td>
</tr>
<tr>
<td>public E removeLast()</td>
<td>移除并返回此列表的最后一个元素</td>
</tr>
</tbody></table>
<h1 id="5-Iterator"><a href="#5-Iterator" class="headerlink" title="5. Iterator"></a>5. Iterator</h1><p>Iterator(迭代器)用于遍<strong>历Collection集合中的元素</strong></p>
<h2 id="5-1-Iterator实例的获取"><a href="#5-1-Iterator实例的获取" class="headerlink" title="5.1 Iterator实例的获取"></a>5.1 Iterator实例的获取</h2><p>调用集合对象的i<strong>terator()方</strong>法，可以获得一个与该集合对象关联的迭代器对象。</p>
<p>Iterator<String> iterator &#x3D; names.iterator();</p>
<h2 id="5-2-常用方法"><a href="#5-2-常用方法" class="headerlink" title="5.2 常用方法"></a>5.2 常用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>boolean  hasNext()</strong></td>
<td>判断游标右边是否有元素。如果有返回true，否则false</td>
</tr>
<tr>
<td><strong>Object  next()</strong></td>
<td>返回游标右边的元素并将游标移动到下一个位置</td>
</tr>
</tbody></table>
<h1 id="6-Collections"><a href="#6-Collections" class="headerlink" title="6. Collections"></a>6. Collections</h1><p>Collections工具类提供了大量针对集合的操作，都为静态方法。</p>
<h2 id="6-1-针对Collection接口"><a href="#6-1-针对Collection接口" class="headerlink" title="6.1 针对Collection接口"></a>6.1 针对Collection接口</h2><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>max(Collection coll)</td>
<td>返回最大元素，要求元素实现Comparable接口</td>
</tr>
<tr>
<td>max(Collection coll, Comparator comp)</td>
<td>根据自定义比较器，返回最大元素</td>
</tr>
<tr>
<td>min(Collection coll)</td>
<td>返回最小元素，要求元素实现Comparable接口</td>
</tr>
<tr>
<td>min(Collection coll, Comparator comp)</td>
<td>根据自定义比较器，返回最小元素</td>
</tr>
<tr>
<td>frequency(Collection c,  Object o)</td>
<td>返回指定集合中指定对象出现的次数</td>
</tr>
</tbody></table>
<h2 id="6-2-针对List接口"><a href="#6-2-针对List接口" class="headerlink" title="6.2 针对List接口"></a>6.2 针对List接口</h2><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>reverse(List list)</td>
<td>反转</td>
</tr>
<tr>
<td>shuffle(List list)</td>
<td>随机排序</td>
</tr>
<tr>
<td>sort(List list)</td>
<td>升序排序，要求元素实现Comparable接口</td>
</tr>
<tr>
<td>sort(List list, Comparator c)</td>
<td>排序</td>
</tr>
<tr>
<td>swap(List list, int i, int j)</td>
<td>元素互换</td>
</tr>
<tr>
<td>rotate(List list, int distance)</td>
<td>右移</td>
</tr>
<tr>
<td>binarySearch(List list, Object key)</td>
<td>二分法搜索，前提是集合已经排序</td>
</tr>
<tr>
<td>replaceAll(List list, Object old, Object new)</td>
<td>替换</td>
</tr>
</tbody></table>
<h1 id="7-Comparable和Comparator"><a href="#7-Comparable和Comparator" class="headerlink" title="7. Comparable和Comparator"></a>7. Comparable和Comparator</h1><p>Comparable和Comparator都是用来实现集合元素排序的</p>
<h2 id="7-1-Comparable"><a href="#7-1-Comparable" class="headerlink" title="7.1 Comparable"></a>7.1 Comparable</h2><p>Comparable位于包java.lang下</p>
<p>对象本身需要实现的接口，内部定义排序(重写compareTo（）方法)</p>
<p><strong>比较规则：返回0&#x3D;顺序相同，返回正数&#x3D;顺序靠后，返回负数&#x3D;顺序靠前</strong></p>
<h2 id="7-2-Comparator"><a href="#7-2-Comparator" class="headerlink" title="7.2 Comparator"></a>7.2 Comparator</h2><p>Comparator位于包Java.util下</p>
<p>在一个独立的类中实现Comparator接口(重写compareTo（）方法)，对象外部实现的排序</p>
<p><strong>比较规则：返回0&#x3D;顺序相同，返回正数&#x3D;顺序靠后，返回负数&#x3D;顺序靠前</strong></p>
<h1 id="8-Set"><a href="#8-Set" class="headerlink" title="8. Set"></a>8. Set</h1><p>Set集合中的元素是不可重复的。Set集合中的元素是无索引的（无序）。Set集合的方法均继承于Collection。</p>
<h2 id="8-1-Set-子类"><a href="#8-1-Set-子类" class="headerlink" title="8.1 Set 子类"></a>8.1 Set 子类</h2><p>HashSet</p>
<p>基于哈希表实现的，是散列结构。数据是无序的。可以放入1个空值null。</p>
<p>TreeSet</p>
<p>基于二叉树实现的，是红黑二叉树结构。数据是有序的。不允许放入null值。</p>
<h2 id="8-2-构造方法"><a href="#8-2-构造方法" class="headerlink" title="8.2 构造方法"></a>8.2 构造方法</h2><table>
<thead>
<tr>
<th><strong>构造方法</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public  HashSet()</td>
<td>构造一个空集合</td>
</tr>
<tr>
<td>public  HashSet(int  initialCapacity)</td>
<td>构造具有指定初始容量的空集合</td>
</tr>
<tr>
<td>public HashSet(Collection&lt;?  extends E&gt; c)</td>
<td>构造一个包含指定集合元素的集合</td>
</tr>
</tbody></table>
<h2 id="8-3-集合遍历"><a href="#8-3-集合遍历" class="headerlink" title="8.3 集合遍历"></a>8.3 集合遍历</h2><p>增强for循环</p>
<p>Iterator</p>
<h2 id="8-4-Set唯一性的判断规则"><a href="#8-4-Set唯一性的判断规则" class="headerlink" title="8.4 Set唯一性的判断规则"></a>8.4 Set唯一性的判断规则</h2><p>分别进行&#x3D;&#x3D;和equals()判断，如果都不相等，则把该对象存入集合中。</p>
<p>根据项目需求，一般会重写hashCode()和equals()方法。</p>
<h2 id="8-5-TreeSet排序"><a href="#8-5-TreeSet排序" class="headerlink" title="8.5 TreeSet排序"></a>8.5 TreeSet排序</h2><p>可以利用TreeSet的二叉树存储特性，将无序的数据存入TreeSet集合中，读取结果会排序。</p>
<h1 id="9-Map"><a href="#9-Map" class="headerlink" title="9. Map"></a>9. Map</h1><h2 id="9-1-Map概述"><a href="#9-1-Map概述" class="headerlink" title="9.1 Map概述"></a>9.1 Map概述</h2><p>实现Map接口的集合类用来存储“<strong>键-值</strong>”映射对（key - value）。</p>
<p>Map通过key来唯一标识，其中key不得重复，而value部分可以重复可以组成一个List。</p>
<p>常用的实现子类有HashMap、TreeMap，它们的区别与HashSet、TreeSet的区别完全一致。</p>
<h2 id="9-2-常用方法"><a href="#9-2-常用方法" class="headerlink" title="9.2 常用方法"></a>9.2 常用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>V put(K key, V value)</td>
<td>将指定的“键-值”对存入Map中。如果key已经存在，则更新value。</td>
</tr>
<tr>
<td>V get(Object key)</td>
<td>返回指定键所映射的值</td>
</tr>
<tr>
<td>V remove(Object key)</td>
<td>根据指定的键把此“键-值”对从Map中移除。</td>
</tr>
<tr>
<td>boolean  containsKey(Object key)</td>
<td>判断此Map是否包含指定键的“键-值”对。</td>
</tr>
<tr>
<td>boolean  containsValue(Object value)</td>
<td>判断此Map是否包含指定值的“键-值”对。</td>
</tr>
<tr>
<td>boolean  isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int  size()</td>
<td>获得些Map中“键-值”对的数量。</td>
</tr>
<tr>
<td>void  clear**()**</td>
<td>清空Map中的所有“键-值”对。</td>
</tr>
</tbody></table>
<h2 id="9-3-Map遍历"><a href="#9-3-Map遍历" class="headerlink" title="9.3 Map遍历"></a>9.3 Map遍历</h2><p><strong>方式1：keySet方式</strong></p>
<p>step1: 通过keySet()获得key的集合</p>
<p>setp2: 遍历key的集合，通过get(Object key)获得Value</p>
<p><strong>方式2：Map.Entry方式</strong></p>
<p>step1:</p>
<p> Map.Entry是Map中内部定义的一个接口，专门用来保存key和value的内容。entrySet()，通过map集合的entrySet()方法来获得所有的Map.Entry组成的set集合。</p>
<p>step2: Map.Entry常用方法</p>
<p>public K getKey()  : 获得key</p>
<p>public V getValue() : 获得Value</p>
<p><strong>方式3：java8的forEach循环</strong></p>
<h2 id="10-线程安全"><a href="#10-线程安全" class="headerlink" title="10. 线程安全"></a>10. 线程安全</h2><p>HashSet、ArrayList、HashMap等开发中常用的集合都是线程不安全的，处理数据效率高。</p>
<p>Collections中封装了SynchronizedSet、SynchronizedList、SynchronizedMap等内部类，属于线程安全的，处理数据效率低。同时Collections提供了多个synchronizedXxx()方法，该方法返回指定集合对象对应的同步对象，从而解决多线程并发访问集合时线程的安全问题。</p>
<p>另外，比如HashTable、Vector 都属于线程安全的。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>流程控制语句</title>
    <url>/2024/10/08/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><span id="more"></span>
<h1 id="1-系统输入"><a href="#1-系统输入" class="headerlink" title="1. 系统输入"></a>1. 系统输入</h1><p>创建扫描器</p>
<p><code>Scanner sc = new Scanner(System.in); //创建扫描器，扫描系统输入</code></p>
<p>读取数据<br>读取数值：nextByte(), nextShort(), nextInt(), nextLong(), nextFloat(), nextDouble()<br>读取字符串：next()<br>int num &#x3D; sc.nextInt(); &#x2F;&#x2F;如果用户没有输入，程序会一直等待<br>String str &#x3D; sc.next();<br>关闭扫描器<br>sc.close(); &#x2F;&#x2F;关闭扫描器，释放资源</p>
<h1 id="2-流程控制的三种结构"><a href="#2-流程控制的三种结构" class="headerlink" title="2.流程控制的三种结构"></a>2.流程控制的三种结构</h1><p>顺序结构：默认的，从上到下依次执行</p>
<p>分支结构：满足某个条件会被执行</p>
<p>循环结构：满足某个条件反复执行</p>
<h1 id="3-if"><a href="#3-if" class="headerlink" title="3. if"></a>3. if</h1><h2 id="3-1-语法格式"><a href="#3-1-语法格式" class="headerlink" title="3.1 语法格式"></a>3.1 语法格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件) &#123; </span><br><span class="line">    <span class="comment">//条件成立时执行的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (条件) &#123; </span><br><span class="line">    <span class="comment">//条件成立时执行的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//条件不成立时执行的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//条件1成立时执行的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123; </span><br><span class="line">    <span class="comment">//条件2成立时执行的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span>  <span class="keyword">if</span> (条件<span class="number">3</span>) &#123; </span><br><span class="line">    <span class="comment">//条件3成立时执行的代码块</span></span><br><span class="line">&#125; ...<span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//如果以上条件都不成立时执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-语法规则"><a href="#3-2-语法规则" class="headerlink" title="3.2 语法规则"></a>3.2 语法规则</h2><p>判断if条件是否成立，如果成立则执行该分支，然后结束if语句。如果不成立，则判断以下else if条件是否成立，如果成立则执行，如果不成立则继续向下判断，以此类推…. 以上都不成立，则执行else分支。</p>
<p>案例1：输入年龄判断是否成年案例<br>案例2：输入成绩，判断成绩等级</p>
<h2 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 后面的大括号如果不加，则默认为只将第一行语句放入 <span class="keyword">if</span> 中</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(num &lt; <span class="number">0</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;aaa&quot;</span>); <span class="comment">//不会执行</span></span><br><span class="line">     System.out.println(<span class="string">&quot;bbb&quot;</span>); <span class="comment">//会执行</span></span><br><span class="line"><span class="keyword">if</span> 语句彼此之间可以相互嵌套</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>); <span class="comment">//会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-switch"><a href="#4-switch" class="headerlink" title="4. switch"></a>4. switch</h1><h2 id="4-1-语法格式"><a href="#4-1-语法格式" class="headerlink" title="4.1 语法格式"></a>4.1 语法格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量/表达式) &#123; </span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span> : </span><br><span class="line">    <span class="comment">//变量等于常量1时执行的代码块</span></span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span> : </span><br><span class="line">    <span class="comment">//变量等于常量2时执行的代码块</span></span><br><span class="line"><span class="keyword">break</span>;   </span><br><span class="line">    .....  </span><br><span class="line"><span class="keyword">default</span>: </span><br><span class="line">    <span class="comment">//以上都不成立时执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-执行流程"><a href="#4-2-执行流程" class="headerlink" title="4.2 执行流程"></a>4.2 执行流程</h2><p>判断变量&#x2F;表达式的值是否等于case的常量，如果相等则执行该分支，然后碰到break终止switch语句。如果不相等，则继续向下判断，以此类推。。。以上条件都不成立时，执行default。</p>
<p>案例：输入数字，输入1则打印“开始游戏”，输入2则打印“暂停游戏”，输入3则打印“退出游戏”。其他输入则打印“输入错误”</p>
<h2 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h2><p>表达式支持的类型：byte、short、int、 char、String、枚举<br>case子句中的取值必须是常量，且取值必须是不同的<br>default子句是可选的<br>break语句用来在执行完一个case分支后使程序跳出switch语句块<br>如果不加break，则语句会继续执行，直到找到break<br>当多个条件采用相同处理方式时，可以共用break</p>
<h1 id="5-while"><a href="#5-while" class="headerlink" title="5. while"></a>5. while</h1><h2 id="5-1-语法格式"><a href="#5-1-语法格式" class="headerlink" title="5.1 语法格式"></a>5.1 语法格式</h2><p>while(循环条件)｛<br>    循环体;<br>}</p>
<h2 id="5-2-执行流程"><a href="#5-2-执行流程" class="headerlink" title="5.2 执行流程"></a>5.2 执行流程</h2><p>循环条件是一个布尔表达式，先判断循环条件是否成立，如果成立执行循环语句。循环后再次判断循环条件是否成立，以此类推…</p>
<p>案例：一根绳子100米，每次剪断1半，问多少次后长度小于5米（不考虑浮点数）#</p>
<h1 id="6-do-while"><a href="#6-do-while" class="headerlink" title="6. do-while"></a>6. do-while</h1><h2 id="6-1-语法格式"><a href="#6-1-语法格式" class="headerlink" title="6.1 语法格式"></a>6.1 语法格式</h2><p>do {<br>    循环体;<br>} while (循环条件); </p>
<h2 id="6-2-执行流程"><a href="#6-2-执行流程" class="headerlink" title="6.2 执行流程"></a>6.2 执行流程</h2><p>先执行一次循环体，再判断循环条件是否成立，如果成立再次执行循环语句。然后再次判断循环条件是否成立，以此类推…</p>
<h1 id="7-for"><a href="#7-for" class="headerlink" title="7. for"></a>7. for</h1><h2 id="7-1-语法格式"><a href="#7-1-语法格式" class="headerlink" title="7.1 语法格式"></a>7.1 语法格式</h2><p>for (初始化①;  循环条件②; 条件变更③)｛<br>    循环语句④;<br>｝</p>
<h2 id="7-2-执行流程"><a href="#7-2-执行流程" class="headerlink" title="7.2 执行流程"></a>7.2 执行流程</h2><p>首先执行初始化①，然后判断循环条件②。如果不成立，循环结束。如果成立执行循环语句④。然后执行条件变更③。然后再次判断循环条件。以此类推…</p>
<p>案例1：打印0到9的数字<br>案例2：计算0到9的和</p>
<h2 id="7-3-for-和-while"><a href="#7-3-for-和-while" class="headerlink" title="7.3 for 和 while"></a>7.3 for 和 while</h2><p>for循环和while循环对于循环逻辑都可以实现，for循环一般用于循环次数已知的情况，while循环一般用于循环次数未知的情况。</p>
<h2 id="7-4-for循环嵌套"><a href="#7-4-for循环嵌套" class="headerlink" title="7.4 for循环嵌套"></a>7.4 for循环嵌套</h2><p>for循环可以嵌套。一般外层相当于对行循环，内层相当于对列循环。<br>&#x2F;&#x2F;需求：输入行数和列数，打印如下图行</p>
<hr>
<hr>
<h1 id="8-终止循环"><a href="#8-终止循环" class="headerlink" title="8. 终止循环"></a>8. 终止循环</h1><h2 id="8-1-break-语句"><a href="#8-1-break-语句" class="headerlink" title="8.1 break 语句"></a>8.1 break 语句</h2><p>终止本层循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-2-break-标志位"><a href="#8-2-break-标志位" class="headerlink" title="8.2 break 标志位"></a>8.2 break 标志位</h2><p>终止指定标志位的循环，开发中使用较少</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">z:</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">break</span> z;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i + <span class="string">&quot; - &quot;</span> + j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-continue-语句"><a href="#8-3-continue-语句" class="headerlink" title="8.3 continue 语句"></a>8.3 continue 语句</h2><p>终止本次循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象编程</title>
    <url>/2024/10/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><span id="more"></span>


<h1 id="1-面向对象编程概述"><a href="#1-面向对象编程概述" class="headerlink" title="1. 面向对象编程概述"></a>1. 面向对象编程概述</h1><h2 id="1-1-面向对象编程"><a href="#1-1-面向对象编程" class="headerlink" title="1.1 面向对象编程"></a>1.1 面向对象编程</h2><p>OOP（Object Oriented Programming），面向对象程序设计</p>
<p>面向对象与面向过程的区别</p>
<p>面向过程侧重整个问题的解决步骤。着眼局部或者具体实现，如C。</p>
<p>面向对象侧重对象抽象，让对象实现功能，在程序中“万事万物皆对象”。着眼于整体，如C++、C#、Java。</p>
<p><strong>思考：如何将大象装入冰箱？</strong></p>
<h2 id="1-2-类与对象的关系"><a href="#1-2-类与对象的关系" class="headerlink" title="1.2. 类与对象的关系"></a>1.2. 类与对象的关系</h2><p>举个例子：“学生小张今年22岁，每天学习到10点。学生小李今年18岁，每天学习到12点”。小张和小李都是一个具体的对象，有姓名和年龄的属性，有学习的行为。而对小张和小李的属性和行为的分析，就可以定义出学生这种类型的特点。</p>
<p>类描述了对象的抽象，是创建对象的模板。java中类是引用类型。 </p>
<p>对象是类的一个实例，是一个实实在在的个体。</p>
<h1 id="2-package"><a href="#2-package" class="headerlink" title="2. package"></a>2. package</h1><h2 id="2-1-包的作用"><a href="#2-1-包的作用" class="headerlink" title="2.1 包的作用"></a>2.1 包的作用</h2><p>工程包：用来区分不同项目</p>
<p>语法：公司域名倒写 + 项目名字</p>
<p>com.baidu.search</p>
<p>功能包：用来区分不同代码功能</p>
<p>写法：在项目包下分包，包名不加s</p>
<p>com.baidu.search.db, com.baidu.search.util</p>
<h2 id="2-2-命名规则"><a href="#2-2-命名规则" class="headerlink" title="2.2 命名规则"></a>2.2 命名规则</h2><p>包名符合 java 命名规范，并且必须全部小写</p>
<p>不同层级之间用“.”来分隔</p>
<h2 id="2-3-包的声明"><a href="#2-3-包的声明" class="headerlink" title="2.3 包的声明"></a>2.3 包的声明</h2><p>声明本类位于哪个包下</p>
<p>使用package声明包，必须放在java文件的首行</p>
<p>package com.bodhixu.java;</p>
<h2 id="2-4-包的导入"><a href="#2-4-包的导入" class="headerlink" title="2.4 包的导入"></a>2.4 包的导入</h2><p>声明本类中所有的java类，位于哪个包下</p>
<p>* 表示包下所有的类</p>
<p>如果要使用的类与当前类属于同一个包，则无需导入</p>
<p>java.lang包中的类，无需导入</p>
<p>import java.util.Scanner;</p>
<h1 id="3-类的定义"><a href="#3-类的定义" class="headerlink" title="3. 类的定义"></a>3. 类的定义</h1><h2 id="3-1-类的组成"><a href="#3-1-类的组成" class="headerlink" title="3.1 类的组成"></a>3.1 类的组成</h2><p>类的关键字是class，内部由成员变量和方法组成。</p>
<p>语法：</p>
<p><strong>class  类名{ &#x2F;&#x2F;类名采用大驼峰式命名</strong></p>
<p>  <strong>&#x2F;&#x2F;成员变量(属性)</strong></p>
<p>  <strong>&#x2F;&#x2F;方法(行为)</strong>   </p>
<p><strong>}</strong></p>
<h2 id="3-2-成员变量"><a href="#3-2-成员变量" class="headerlink" title="3.2 成员变量"></a>3.2 成员变量</h2><p>成员变量是对属性的描述。变量的数据类型可以是Java的任何数据类型，变量名采用小驼峰式命名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;   </span><br><span class="line"></span><br><span class="line">   String name; <span class="comment">//姓名</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> age; <span class="comment">//年龄   </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>3.3 方法</strong></p>
<p>方法是对行为的描述。方法名采用小驼峰式命名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">​     System.out.println(<span class="string">&quot;吃饭了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">​     System.out.println(<span class="string">&quot;学习了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在同一个类中，方法中可以调用自身的成员变量和方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   String name; <span class="comment">//姓名</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">​     System.out.println(<span class="string">&quot;吃饭了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">​     System.out.println(<span class="string">&quot;学习了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">life</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">​     eat();</span><br><span class="line"></span><br><span class="line">​     study();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">​     System.out.println(<span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age);   </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="4-对象的创建和使用"><a href="#4-对象的创建和使用" class="headerlink" title="4. 对象的创建和使用"></a>4. 对象的创建和使用</h1><h2 id="4-1-对象的创建"><a href="#4-1-对象的创建" class="headerlink" title="4.1 对象的创建"></a>4.1 对象的创建</h2><p>声明： 类名 对象名;</p>
<p>实例化(初始化): 对象名 &#x3D; new 类名();</p>
<p>Student stu &#x3D; new Student();</p>
<h2 id="4-2-对象调用属性和方法"><a href="#4-2-对象调用属性和方法" class="headerlink" title="4.2 对象调用属性和方法"></a>4.2 对象调用属性和方法</h2><p>用<strong>“.”</strong>运算符来调用</p>
<p>&#x2F;&#x2F;对象调用属性</p>
<p>stu1.name &#x3D; “小张”;</p>
<p>stu1.age &#x3D; 22;</p>
<p>Systemt.out.println(stu1.name);</p>
<p>&#x2F;&#x2F;对象调用方法</p>
<p>stu1.eat();</p>
<p>stu1.study();</p>
<h1 id="5-参数"><a href="#5-参数" class="headerlink" title="5. 参数"></a>5. 参数</h1><h2 id="5-1-参数作用"><a href="#5-1-参数作用" class="headerlink" title="5.1 参数作用"></a>5.1 参数作用</h2><p>方法运行时，可以通过参数（即方法参数）给方法内部传递数据。</p>
<h2 id="5-2-形参和实参"><a href="#5-2-形参和实参" class="headerlink" title="5.2 形参和实参"></a>5.2 形参和实参</h2><p>形参：定义方法时使用的参数。它是形式上的参数，变量名不重要，数据类型重要。</p>
<p>实参：调用方法时实际传给方法的数据。实参的数据类型由形参来决定。</p>
<p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsEB48.tmp.jpg" alt="img"> </p>
<h2 id="5-3-值传递和引用传递"><a href="#5-3-值传递和引用传递" class="headerlink" title="5.3 值传递和引用传递"></a>5.3 值传递和引用传递</h2><p>值传递：传递的是值的副本，即数据值。参数类型包括基本类型和Sring。</p>
<p>引用传递：传递的是引用的副本，即内存地址。参数类型包括非String的引用类型。</p>
<h2 id="5-4-可变参数"><a href="#5-4-可变参数" class="headerlink" title="5.4 可变参数"></a>5.4 可变参数</h2><p>可变参数是指参数的数量是可变的。</p>
<p><strong>定义</strong></p>
<p>参数类型后使用…表示可变参数</p>
<p>可变参数必须定义在方法参数列表的尾部，因此一个方法最多只能有一个可变参数</p>
<p>方法内部把可变参数当做数组处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line"></span><br><span class="line">​     <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line"></span><br><span class="line">​       sum += nums;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">   &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>调用</strong></p>
<p>方法调用时，可以传入0个，1个，多个参数，也可以传入数组或集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line"></span><br><span class="line">​     <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line"></span><br><span class="line">​       sum += nums;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">   &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> MathUtils.getSum();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> MathUtils.getSum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum3</span> <span class="operator">=</span> MathUtils.getSum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum4</span> <span class="operator">=</span> MathUtils.getSum(array);</span><br></pre></td></tr></table></figure>


<h1 id="6-返回值和返回值类型"><a href="#6-返回值和返回值类型" class="headerlink" title="6. 返回值和返回值类型"></a>6. 返回值和返回值类型</h1><h2 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6.1 作用"></a>6.1 作用</h2><p>方法运行结束，返回数据给调用者。</p>
<h2 id="6-2-返回类型"><a href="#6-2-返回类型" class="headerlink" title="6.2 返回类型"></a>6.2 返回类型</h2><p>返回数据的类型称为返回类型，可以是java中的任意类型。</p>
<p>void是一种特殊返回类型，称为”无返回”。</p>
<h2 id="6-3-返回值"><a href="#6-3-返回值" class="headerlink" title="6.3 返回值"></a>6.3 返回值</h2><p>返回的具体数据称为返回值。</p>
<p>通过return返还给调用者的具体数据。</p>
<p>&#x2F;&#x2F;需求:计算2个数的和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathUtils</span>&#123;   </span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">​       x *= -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">   &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>void方法碰到return会自动结束方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomUtils</span>&#123;   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String msg, <span class="type">boolean</span> exit)</span>&#123;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">if</span>(exit) &#123;</span><br><span class="line"></span><br><span class="line">​       <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     System.out.println(msg);</span><br><span class="line"></span><br><span class="line">   &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>class Test{</p>
<p>   public static void main(String[] args) {</p>
<p>​     CustomUtils cu &#x3D; new CustomUtils();</p>
<p>​     cu.show(“abc”, true);</p>
<p>   }</p>
<p>}</p>
<p><strong>思考：① 求一个数的绝对值 ② 对数组进行排序，封装这两个方法是否需要返回值？</strong></p>
<h1 id="7-构造方法"><a href="#7-构造方法" class="headerlink" title="7. 构造方法"></a>7. 构造方法</h1><h2 id="7-1-基本语法"><a href="#7-1-基本语法" class="headerlink" title="7.1 基本语法"></a>7.1 基本语法</h2><p>方法名和类名相同</p>
<p>没有返回类型</p>
<p>public class Student {</p>
<p>  String name;</p>
<p>  int age;</p>
<p>  public Student(String name, int age) {</p>
<p>​    this.name &#x3D; name;</p>
<p>​    this.age &#x3D; age;</p>
<p>  }</p>
<p>}</p>
<h2 id="7-2-作用"><a href="#7-2-作用" class="headerlink" title="7.2 作用"></a>7.2 作用</h2><p>构造方法的作用在于构造并初始化对象</p>
<p>当实例化对象（new）的时候，系统自动调用</p>
<h2 id="7-3-隐式构造方法"><a href="#7-3-隐式构造方法" class="headerlink" title="7.3 隐式构造方法"></a>7.3 隐式构造方法</h2><p>如果类中没有显式定义构造方法，系统会提供一个隐式的无参构造方法</p>
<p>如果类中显式定义了构造方法，则默认的隐式构造方法就不存在了。</p>
<p>如果需要用到无参构造方法，则必须再显式定义。</p>
<h1 id="8-封装"><a href="#8-封装" class="headerlink" title="8. 封装"></a>8. 封装</h1><h2 id="8-1-面向对象三大特征"><a href="#8-1-面向对象三大特征" class="headerlink" title="8.1 面向对象三大特征"></a>8.1 面向对象三大特征</h2><p><strong>封装、继承、多态</strong></p>
<h2 id="8-2-封装性的理解"><a href="#8-2-封装性的理解" class="headerlink" title="8.2 封装性的理解"></a>8.2 封装性的理解</h2><p>在进行程序设计时，应尽量避免一个模块直接修改或操作另一个模块的数据，模块设计追求<strong>强内聚和弱耦合</strong>。封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口（或方法）。</p>
<h2 id="8-3-封装性的实现"><a href="#8-3-封装性的实现" class="headerlink" title="8.3 封装性的实现**"></a>8.3 封装性的实现**</h2><p>step1：将类的成员变量私有化（使用private声明）</p>
<p>step2：提供setter方法和getter方法供外部访问</p>
<h1 id="9-继承"><a href="#9-继承" class="headerlink" title="9. 继承"></a>9. 继承</h1><h2 id="9-1-继承的理解"><a href="#9-1-继承的理解" class="headerlink" title="9.1 继承的理解"></a>9.1 继承的理解</h2><p>继承可以最大程度实现功能复用，便于项目的维护和管理</p>
<h2 id="9-2-相关概念"><a href="#9-2-相关概念" class="headerlink" title="9.2 相关概念"></a>9.2 相关概念</h2><p>子类：实现继承的类称为子类(subclass)，也叫派生类</p>
<p>父类：被继承的类称为父类(superclass)，也叫超类或基类</p>
<h2 id="9-3-继承实现"><a href="#9-3-继承实现" class="headerlink" title="9.3 继承实现"></a>9.3 继承实现</h2><p>使用关键字extends</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="9-4-继承规则"><a href="#9-4-继承规则" class="headerlink" title="9.4 继承规则"></a>9.4 继承规则</h2><p>父类中私有的成员变量和方法不能被继承</p>
<p>父类的构造方法不能被继承，但可以调用（后面将super）</p>
<p>Java只支持单继承</p>
<p>Java支持多层继承（java中所有的类，都是继承自Object）</p>
<h1 id="10-访问权限修饰符"><a href="#10-访问权限修饰符" class="headerlink" title="10. 访问权限修饰符"></a>10. 访问权限修饰符</h1><p>访问权限修饰符可以设置内容的访问权限</p>
<table>
<thead>
<tr>
<th><strong>修饰符</strong></th>
<th><strong>本类中</strong></th>
<th><strong>本包中</strong></th>
<th><strong>子类中</strong></th>
<th><strong>全局</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>yes</td>
<td></td>
<td></td>
<td></td>
<td>封装性、本类自己用的</td>
</tr>
<tr>
<td>无修饰</td>
<td>yes</td>
<td>yes</td>
<td></td>
<td></td>
<td>无特殊需求的</td>
</tr>
<tr>
<td>protected</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td></td>
<td>父类被继承的</td>
</tr>
<tr>
<td>public</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>工具类等通用的</td>
</tr>
</tbody></table>
<p>对象和方法可以使用任意访问权限修饰符</p>
<p>类和接口（后面将）只能有 public 和 无修饰 两种权限</p>
<h1 id="11-方法重载和方法重写"><a href="#11-方法重载和方法重写" class="headerlink" title="11. 方法重载和方法重写"></a>11. 方法重载和方法重写</h1><h2 id="11-1-方法的重载overload"><a href="#11-1-方法的重载overload" class="headerlink" title="11.1 方法的重载overload"></a>11.1 方法的重载overload</h2><p>前提：在同一个类中</p>
<p>规则：一同一不同</p>
<p>一同：方法名相同</p>
<p>一不同：参数列表不同。参数列表不同包括参数类型或参数个数或参数顺序不同。</p>
<p>返回类型、访问权限和异常范围没有限制</p>
<p>普通方法、构造方法都可以重载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomUtils</span>&#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">return</span> x + y;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span>&#123;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">return</span> x + y + z;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="11-2-方法的重写（也叫覆写）overwrite-（也叫override）"><a href="#11-2-方法的重写（也叫覆写）overwrite-（也叫override）" class="headerlink" title="11.2 方法的重写（也叫覆写）overwrite （也叫override）"></a>11.2 方法的重写（也叫覆写）overwrite （也叫override）</h2><p>前提：存在继承关系，子类重写父类的方法</p>
<p>规则：二同二小一大</p>
<p>二同： 方法名相同、参数列表相同</p>
<p>二小： 子类返回类型和父类相同或者是父类返回类型的子类，子类中抛出的异常范围比父类小或者与父类相同(后续会讲)</p>
<p>一大： 子类中访问控制权限比父类的大或者相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">​     System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;  </span><br><span class="line"></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">​     System.out.println(<span class="string">&quot;学生叫外卖&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="12-this-和-super"><a href="#12-this-和-super" class="headerlink" title="12. this 和 super"></a>12. this 和 super</h1><h2 id="12-1-this"><a href="#12-1-this" class="headerlink" title="12.1 this"></a>12.1 this</h2><p>调用本类成员变量和方法，说明：一般用于成员变量名称和方法参数名称重名时</p>
<p><strong>this.变量</strong></p>
<p><strong>this.方法(参数)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">​     <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用本类构造方法，必须放在的该构造方法的首行</p>
<p><strong>this(参数)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">long</span> id;   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">​     <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">​     <span class="built_in">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">long</span> id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">​     <span class="built_in">this</span>(name, age);</span><br><span class="line"></span><br><span class="line">​     <span class="built_in">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示当前对象的内存地址。</p>
<h2 id="12-2-super"><a href="#12-2-super" class="headerlink" title="12.2 super"></a>12.2 super</h2><p>调用父类的成员变量和方法，用户和this一致</p>
<p>调用父类构造方法，用户和this一致</p>
<h1 id="13-final"><a href="#13-final" class="headerlink" title="13. final"></a>13. final</h1><p>final翻译成中文是“最终的”意思，可以修饰变量、方法和类，优势在于可以提高访问速度。</p>
<h2 id="13-1-修饰变量"><a href="#13-1-修饰变量" class="headerlink" title="13.1 修饰变量"></a>13.1 修饰变量</h2><p>final修饰的变量，称为常量。常量只能被赋一次。</p>
<p>final一般和static配合使用定义状态码，如public static final int STATE_LOADING &#x3D; 10;</p>
<h2 id="13-2-修饰方法"><a href="#13-2-修饰方法" class="headerlink" title="13.2 修饰方法"></a>13.2 修饰方法</h2><p>final修饰的方法，不能被重写</p>
<h2 id="13-3-修饰类"><a href="#13-3-修饰类" class="headerlink" title="13.3 修饰类"></a>13.3 修饰类</h2><p>final修饰的类，不能被继承</p>
<h1 id="14-static"><a href="#14-static" class="headerlink" title="14. static"></a>14. static</h1><p>static 翻译成中文叫“静态的”，可以修饰变量、方法、构造代码块。静态事物独立于类的实例（即对象），所有对象中的静态事物共享一块存储区。</p>
<h2 id="14-1-静态变量"><a href="#14-1-静态变量" class="headerlink" title="14.1 静态变量"></a>14.1 静态变量</h2><p>定义：用static修饰的成员变量，叫静态变量，也叫类变量。如：public  static  int  a;</p>
<p> 普通的成员变量，叫做实例变量。</p>
<p>访问：通过类名访问静态变量</p>
<p>应用场景：一般和final一起使用，表示静态常量</p>
<p><code>public static final DAYS_IN_WEEK = 7; //1周7天</code></p>
<h2 id="14-2-静态方法"><a href="#14-2-静态方法" class="headerlink" title="14.2 静态方法"></a>14.2 静态方法</h2><p>定义：用static修饰的方法，叫静态方法，也叫类方法。</p>
<p>静态方法中只能调用静态变量和静态方法</p>
<p>静态方法中不能使用this和super</p>
<p>static方法不能被重写</p>
<p>应用场景：一般工具类中的方法使用static</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line"></span><br><span class="line">​     <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line"></span><br><span class="line">​       sum += nums;</span><br><span class="line"></span><br><span class="line">​     &#125;</span><br><span class="line"></span><br><span class="line">​     <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">   &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="14-3-静态构造代码块"><a href="#14-3-静态构造代码块" class="headerlink" title="14.3 静态构造代码块"></a>14.3 静态构造代码块</h2><p>概念</p>
<p>构造代码块：在类中直接用一对大括号括起来的一段代码</p>
<p>静态代码块：用static修饰的构造代码块称之为静态代码块</p>
<p>区别</p>
<p>构造代码块在每次new对象的时候都会执行一次</p>
<p>静态代码块只有在类第一次加载到内存的时候执行一次</p>
<p>应用场景：一般执行一次的初始化操作放在静态构造代码块中</p>
<h2 id="14-4-注意事项"><a href="#14-4-注意事项" class="headerlink" title="14.4 注意事项"></a>14.4 注意事项</h2><p>静态事物一旦分配内存，则无法手动回收，直到程序结束。因此非必要时尽量避免使用。</p>
<h1 id="15-抽象"><a href="#15-抽象" class="headerlink" title="15. 抽象"></a>15. 抽象</h1><h2 id="15-1-抽象的理解"><a href="#15-1-抽象的理解" class="headerlink" title="15.1 抽象的理解"></a>15.1 抽象的理解</h2><p>只规定了行为，但不规定具体的实现。比如父类Person中只规定了吃的行为，至于怎么吃由子类Student和Teacher具体决定。</p>
<h2 id="15-2-抽象方法"><a href="#15-2-抽象方法" class="headerlink" title="15.2 抽象方法"></a>15.2 抽象方法</h2><p>使用abstract修饰，没有方法体（没有方法实现）</p>
<p><code>public abstract void eat();</code></p>
<h2 id="15-3-抽象类"><a href="#15-3-抽象类" class="headerlink" title="15.3 抽象类"></a>15.3 抽象类</h2><p>使用abstract来修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类中如果出现了抽象方法，则该类必须标记为抽象类</p>
<p>抽象类中可以没有抽象方法</p>
<p>抽象类中可以有普通类中有的任何元素 (成员变量、静态变量、实例方法、静态方法、构造方法等)</p>
<p>不能实例化抽象类的对象，抽象类必须被继承使用</p>
<p>子类继承抽象类时，或者实现父类的抽象方法，或者子类也标记为抽象类。</p>
<h1 id="16-接口"><a href="#16-接口" class="headerlink" title="16. 接口"></a>16. 接口</h1><h2 id="16-1-接口的理解"><a href="#16-1-接口的理解" class="headerlink" title="16.1 接口的理解"></a>16.1 接口的理解</h2><p>抽象类不但允许有抽象方法，还可以有成员变量和普通方法等。如果抽象的更彻底，只留下常量和抽象方法，则需要使用接口。</p>
<p>接口可以理解为对行为或规范的定义。面向对象的最高境界，是面向接口编程！！！（更好的扩展性和较低的耦合性）</p>
<h2 id="16-2-接口的声明"><a href="#16-2-接口的声明" class="headerlink" title="16.2 接口的声明"></a>16.2 接口的声明</h2><p>[权限修饰符]  interface  接口名</p>
<p>关键字 interface</p>
<p>访问权限修饰符和类一样，只有public和无修饰两种</p>
<p>接口名一般以I或On开头、以able或者Listener结尾</p>
<h2 id="16-3-接口内部组成"><a href="#16-3-接口内部组成" class="headerlink" title="16.3 接口内部组成"></a>16.3 接口内部组成</h2><p>JDK8之前，接口内部只能包括公有的静态常量和公有的抽象方法，JDK8对接口进行了扩展（后面讲解）。</p>
<p>修饰符可以完全省略，自动编译时自动添加</p>
<h2 id="16-4-接口的父接口"><a href="#16-4-接口的父接口" class="headerlink" title="16.4 接口的父接口"></a>16.4 接口的父接口</h2><p>接口可以继承多个父接口，用extends。</p>
<h2 id="16-5-接口的实现"><a href="#16-5-接口的实现" class="headerlink" title="16.5 接口的实现"></a>16.5 接口的实现</h2><p>关键字 implements</p>
<p>一个类可以实现多个接口，多个接口之间使用逗号隔开。</p>
<p>实现类必须实现所有接口的所有抽象方法，如果不能完全实现，则该类必须标记为抽象类。</p>
<p>一个类实现多个接口的同时，还可以来继承一个类。必须先写继承，再写实现。</p>
<h1 id="17-多态"><a href="#17-多态" class="headerlink" title="17. 多态*"></a>17. 多态*</h1><h2 id="17-1-编译时类型和运行时类型"><a href="#17-1-编译时类型和运行时类型" class="headerlink" title="17.1 编译时类型和运行时类型"></a>17.1 编译时类型和运行时类型</h2><p>编译时类型：编译时类型由声明该变量时使用的类型决定(赋值运算符左边)</p>
<p>运行时类型：运行时类型由实际赋给该变量的对象决定(赋值运算符右边)</p>
<p>Persont person &#x3D; new Student();</p>
<h2 id="17-2-多态的概念"><a href="#17-2-多态的概念" class="headerlink" title="17.2 多态的概念"></a>17.2 多态的概念</h2><p>父类引用指向子类对象，又称为编译时类型和运行时类型不一致</p>
<h2 id="17-3-自动类型转换和强制类型转换"><a href="#17-3-自动类型转换和强制类型转换" class="headerlink" title="17.3 自动类型转换和强制类型转换"></a>17.3 自动类型转换和强制类型转换</h2><p>自动类型转换：父类引用指向子类对象</p>
<p><code>Persont person = new Student();</code></p>
<p>父类引用只能直接调用父类中存在的方法，不能调用子类中新增的方法(否则会出现编译错误：找不到方法)，因为此时的编译时类型是父类类型</p>
<p>强制类型转换：父类引用强转成子类对象</p>
<p><code>Student stu = (Student)p;</code></p>
<p>强制类型转换有风险，如果类型不匹配就会产生异常ClassCastException</p>
<h2 id="17-4-instanceof"><a href="#17-4-instanceof" class="headerlink" title="17.4  instanceof"></a>17.4  instanceof</h2><p>类型判断，判断对象是否属于该类型</p>
<p>语法：对象名  instanceof  数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Persont</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (person <span class="keyword">instanceof</span> Student) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="18-内部类"><a href="#18-内部类" class="headerlink" title="18. 内部类"></a>18. 内部类</h1><h2 id="18-1-概念"><a href="#18-1-概念" class="headerlink" title="18.1 概念"></a>18.1 概念</h2><p>将一个类定义在另一个类的里面，对于里面那个类就称为内部类（内置类，嵌套类）。内部类包括成员内部类、<strong>匿名内部类</strong>、局部内部类、静态内部类等。</p>
<h2 id="18-2-成员内部类"><a href="#18-2-成员内部类" class="headerlink" title="18.2 成员内部类"></a>18.2 成员内部类</h2><p>优点：可以自由访问外部类的成员</p>
<p>缺点：破坏了类的结构，降低了代码可读性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publc <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"></span><br><span class="line">​     </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br></pre></td></tr></table></figure>
<h2 id="18-3-匿名内部类"><a href="#18-3-匿名内部类" class="headerlink" title="18.3 匿名内部类"></a>18.3 匿名内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IAnimal</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(IAnimal animal)</span> &#123;</span><br><span class="line"></span><br><span class="line">​    animal.eat();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p.feed(<span class="keyword">new</span> <span class="title class_">IIAnimal</span>() &#123;     </span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">​     System.out.println(<span class="string">&quot;动物吃饭了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h1 id="19-枚举"><a href="#19-枚举" class="headerlink" title="19. 枚举"></a>19. 枚举</h1><h2 id="19-1-概念"><a href="#19-1-概念" class="headerlink" title="19.1 概念"></a>19.1 概念</h2><p>enum（ enumeration），枚举的定义是为了将一组相关常量统一管理。实际开发中的错误码、状态码等一般使用枚举定义。</p>
<h2 id="19-2-声明和调用"><a href="#19-2-声明和调用" class="headerlink" title="19.2 声明和调用"></a>19.2 声明和调用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">声明</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123; </span><br><span class="line"></span><br><span class="line">  RED, <span class="comment">// 红色</span></span><br><span class="line"></span><br><span class="line">  GREEN, <span class="comment">// 绿色</span></span><br><span class="line"></span><br><span class="line">  BLUE <span class="comment">// 蓝色</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举的调用</span></span><br><span class="line"></span><br><span class="line">System.out.println(Color.RED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> 使用枚举</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch使用枚举</span></span><br><span class="line"></span><br><span class="line"><span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> Color.BLUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(color) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> RED:</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;RED...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> GREEN:</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;GREEN...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> BLUE:</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;BLUE...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-3-常用方法"><a href="#19-3-常用方法" class="headerlink" title="19.3 常用方法"></a>19.3 常用方法</h2><p>Java 中的每一个枚举都继承自 java.lang.Enum 类。当定义一个枚举类型时，每一个枚举类型成员都可以看作是 Enum 类的实例，这些枚举成员默认都被 final、public, static 修饰。如果枚举不添加任何方法，枚举类型成员的枚举值默认为从0开始的有序数值。</p>
<p>values()：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。</p>
<p>name()：返回实例名。</p>
<p>ordinal()：返回实例声明时的次序，从0开始。</p>
<p>equals()：判断是否为同一个对象。也可以使用&#x3D;&#x3D;判断，效果是一致的。</p>
<p>System.out.println(Color.values()[1]);</p>
<p>Color color &#x3D; Color.GREEN;</p>
<p>System.out.println(color.name());</p>
<p>System.out.println(color.ordinal());</p>
<p>Color color2 &#x3D; Color.GREEN;</p>
<p>System.out.println(color.equals(color2));</p>
<p>System.out.println(color &#x3D;&#x3D; color2);</p>
<h2 id="19-4-构造方法和自定义方法"><a href="#19-4-构造方法和自定义方法" class="headerlink" title="19.4 构造方法和自定义方法"></a>19.4 构造方法和自定义方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color2</span>&#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  BLACK(<span class="string">&quot;AA&quot;</span>), <span class="comment">// 红色</span></span><br><span class="line"></span><br><span class="line">  RED(<span class="string">&quot;BB&quot;</span>), <span class="comment">// 绿色</span></span><br><span class="line"></span><br><span class="line">  GREEN(<span class="string">&quot;CC&quot;</span>); <span class="comment">// 蓝色</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法默认是private</span></span><br><span class="line"></span><br><span class="line">  Color2(String name) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-5-注意事项"><a href="#19-5-注意事项" class="headerlink" title="19.5 注意事项"></a>19.5 注意事项</h2><p>声明枚举时，所有的值必须写注释</p>
<p>枚举可以用于方法参数类型，但是不建议作为方法返回类型</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
</search>
